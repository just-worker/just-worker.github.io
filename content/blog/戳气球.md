---
title: "戳气球"
date: 2023-11-06T20:41:45+08:00
draft: false
tags: ["leetcode", "算法"]
---

## [戳气球](https://leetcode.cn/problems/burst-balloons/)

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

>- 输入：nums = [3,1,5,8]
>- 输出：167
>- 解释：
>- nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
>- coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167


## 题目解析

```rust

// time: O(N ^ 3)
// space: O(N ^ 2)
impl Solution {
    pub fn max_coins(mut nums: Vec<i32>) -> i32 {
        let mut values = Vec::with_capacity(nums.len() + 2);
        values.push(1);
        values.append(&mut nums);
        values.push(1);
        let mut res = vec![vec![-1; values.len()]; values.len()];
        Self::solve(0, values.len() - 1, &values, &mut res)
    }

    fn solve(left: usize, right: usize, values: &Vec<i32>, res: &mut Vec<Vec<i32>>) -> i32 {
        if left >= right - 1 {
            return 0;
        }
        if res[left][right] != -1 {
            return res[left][right];
        }
        for curr in left + 1..right {
            let ans = values[left] * values[curr] * values[right]
                + Self::solve(left, curr, values, res)
                + Self::solve(curr, right, values, res);
            res[left][right] = res[left][right].max(ans);
        }
        return res[left][right];
    }
}
```

## 选举递归

递归的三大要素
1. 自我调用
2. 边界条件
3. 状态流转

前两点不必多说，核心在于 `状态流转`，这也是每次递归都会说到`递推方程`的原因，这是一个递归问题最核心的地方。

它的作用就是将一个问题状态，逐步转移，最终到达边界条件，从而计算出结果。

但是这种状态流转，可以详细划分为两类
1. 直接依赖
2. 结果选举

基础的`直接依赖`，比如菲波那切数列，其中的状态流转是显而易见的，而且是直接依赖的，通过直接的计算就可以得到具体的结果。
而`结果选举`，顾名思义，它并不能直接计算出结果，它需要遍历一次递归阶段的全部可能，然后在这些结果中进行选举，才能具体得出当前递归的确切的值。

比如这道题：矩阵中有数，只能向右或者向下，求从左上角到右下角和最大的路径。
每一格子，都需要去对比两个方向的值，才能确定当前格子的最大值，这就是`结果选举`。

显而易见的是，对于`结果选举`，必须要有一个地方存储这些递归的结果，才能将选举进行下去。
而递归的自相似性要求了，局部递归结果的存储和整体递归流程的存储将会是同一个。那整个递归流程大概就是这样的：
1. 共享一个递归上下文
2. 递归结果会存储在上下文中
3. 选举出来的递归结果也会存在上下文中
4. 递归之间的依赖，也通过上下文进行传递

和前面矩阵求和的例子有差异的是，就如同本题一样，部分题目的递归不同一般
1. 递归的结果终究会出来，但是不一定发生在边界条件计算的时候
2. 递归之间总有关系，但是具体的执行顺序不一定很明确

本题在边界的时候的确计算了一个值，但是对于具体先添加左边还是先添加右边的问题上，依赖数值是边界条件时候计算的，但是值的选举是发生在后续的递归中。

和上一点类似，我们最终确定了一个值，但是对于这个值是哪一轮递归计算、筛选的，顺序上面并不很明确。

面对这种递归问题，我们只能明确如下步骤
1. 详细描述边界计算
2. 详细描述选举规则
3. 记住时刻更新上下文

理解上或许还欠火候，但是这样去解题，基本不会出错。

> 可以发现，就是因为上下文的透传，加上递归自相似的计算和引用、每一轮递归结果的选举和更新，才导致了顺序和步骤的不明却。       

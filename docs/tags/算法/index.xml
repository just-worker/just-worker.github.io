<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on just-worker</title>
    <link>https://just-worker.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on just-worker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Tue, 06 Jun 2023 23:59:17 +0800</lastBuildDate><atom:link href="https://just-worker.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符串转换整数</title>
      <link>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</link>
      <pubDate>Tue, 06 Jun 2023 23:59:17 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;字符串转换整数httpsleetcodecnproblemsstring-to-integer-atoi&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/string-to-integer-atoi/&#34;&gt;字符串转换整数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。&lt;/p&gt;
&lt;p&gt;函数 myAtoi(string s) 的算法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入字符串并丢弃无用的前导空格&lt;/li&gt;
&lt;li&gt;检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。&lt;/li&gt;
&lt;li&gt;读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。&lt;/li&gt;
&lt;li&gt;将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。&lt;/li&gt;
&lt;li&gt;如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。&lt;/li&gt;
&lt;li&gt;返回整数作为最终结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;直接解题就好了，注意其中两个个坑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始解析之后，非数字字符都要中断解析，包括符号位和空格。&lt;/li&gt;
&lt;li&gt;解析开始的标记，可以是数字字符，也可以是符号位。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;my_atoi&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch.is_numeric() {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; ;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; doing {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt; {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; {
                    sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;边界问题，小心检查。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整数反转</title>
      <link>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 06 Jun 2023 23:50:22 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;h2 id=&#34;整数反转httpsleetcodecnproblemsreverse-integer&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/reverse-integer/&#34;&gt;整数反转&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：x = 123&lt;/li&gt;
&lt;li&gt;输出：321&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(LEN) 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; sign;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主要在于边界判断&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N字形变换</title>
      <link>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Tue, 06 Jun 2023 22:49:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      <description>&lt;h2 id=&#34;n字形变换httpsleetcodecnproblemszigzag-conversion&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/&#34;&gt;N字形变换&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &amp;ldquo;PAYPALISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;直接使用模拟的办法进行解析的话，明显会造成空间的浪费，这里就不说了，详细可以看&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/&#34;&gt;官网解答&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;直接计算&#34;&gt;直接计算&lt;/h3&gt;
&lt;p&gt;我们可以思考的是，能够通过数学的规律，直接进行计算。&lt;/p&gt;
&lt;p&gt;分行&lt;code&gt;lines&lt;/code&gt;，明显观察到的规律就是，整个字符周期&lt;code&gt;batch = lines + lines - 2&lt;/code&gt;，其中因为对称的第二列首尾被截取掉了。&lt;/p&gt;
&lt;p&gt;其次，在向上的填充，有对称的部分，很轻易能够计算出，他们的位置其实就是关于&lt;code&gt;lines&lt;/code&gt;的对称。&lt;/p&gt;
&lt;p&gt;现在，分为&lt;code&gt;lines&lt;/code&gt;行，我们直接计算一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![]; lines];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i, ch) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars().enumerate() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; batch;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
                res[idx].push(ch);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res[batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; idx].push(ch);
            }
        }
        res.concat().iter().collect()
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;直接生成&#34;&gt;直接生成&lt;/h3&gt;
&lt;p&gt;直接计算已经非常不错了，核心关系我们也找到了，能够继续优化呢。&lt;/p&gt;
&lt;p&gt;如果我们直接生成结果，而不用借助多个数组，会怎么样子。可以预见的是，我们将遍历不止一次，重复遍历的次数为&lt;code&gt;lines x N&lt;/code&gt;，时间复杂度并不会涨，但是空间复杂度会降低到&lt;code&gt;O(1)&lt;/code&gt;，因为生成的就是结果本身，不算辅助空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; offset &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; batch;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; chars.len()  {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len() {
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset]);
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; offset;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 独行不重复计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len(){
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror]);
                }
                factor &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里主要的变异点在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要重复遍历&lt;code&gt;lines&lt;/code&gt;遍&lt;/li&gt;
&lt;li&gt;有些行的遍历，一个周期内需要添加两个字符&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串2</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</link>
      <pubDate>Mon, 05 Jun 2023 22:55:57 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</guid>
      <description>&lt;h2 id=&#34;前情回顾&#34;&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/&#34;&gt;最长回文子串&lt;/a&gt;中，我们尝试过两种办法去解答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递推：使用空间记录计算过的结果&lt;/li&gt;
&lt;li&gt;扩展：直接扩展计算匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们尝试去解决这两个方案的缺点。在此之前，因为&lt;code&gt;rust&lt;/code&gt;语法和我不想对&lt;code&gt;i32&lt;/code&gt;妥协的原因，前面的&lt;code&gt;expand&lt;/code&gt;方法实现比较扭曲。
为了这次扩展，重写一下&lt;code&gt;expand&lt;/code&gt;，对&lt;code&gt;i32&lt;/code&gt;进行妥协。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;h3 id=&#34;奇偶串&#34;&gt;奇偶串&lt;/h3&gt;
&lt;p&gt;在使用中心扩展的时候，我们需要扩展两次，因为我们不确定它是奇串还是偶串。这里有一个特殊的特性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于奇数串，它的可插入空位是偶数；对于偶数串，它的可插入空位是奇数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个特性，我们可以对原字符串进行空插，最后得出的一定是奇串；最后去剔除掉插入的字符，这样就能够完美解决奇偶串的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这里的#字符并非一定要是原生字符串之外的字符；因为它自带的对称性并不破坏原有数据的对称性；根据它空插的特性，也可以详细的指定移除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算记忆&#34;&gt;计算记忆&lt;/h3&gt;
&lt;p&gt;之前使用递推，结果不仅时间复杂度没有降低，空间复杂度反而更高，这是为什么呢。主要在于遍历的非线性。我们固然在逻辑上创建了一个具有线性关系的递推式，但是实际遍历过程中，为了维护这种逻辑的线性，我们的遍历方式反而是非线性的，这决定了它的时间复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。其次，我们的存储结构，也要求了空间的复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，核心的关系在于，我们能够找出一种线性的遍历关系，让我们既能线性遍历，又能复用计算结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在强制要求线性遍历的场景下，我们先考察一下是否能够有一种办法去传递我们的计算结果。&lt;/p&gt;
&lt;p&gt;对于未遍历导的场景，遍历是必然的。我们假设在遍历到的一个回文串中，关于中心点对称的两个点的性质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为空插字符，始终是奇串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为两个点都是对称的，因此，他们的回文状态必然也是对称的；这样，的确存在了我们可以复用的传递关系。如果对称点不对称，我们必然要重新进行计算，这里当然选用中心扩展的办法。&lt;/p&gt;
&lt;p&gt;这里引申出两个问题：我们需要如何确定这个对称的中心点，我们需要如何利用这个关系进行传导计算。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了尽可能的复用计算结果，需要尽量将要计算的结果包裹在已经计算的范围内，因此，我们需要最靠近右边的中心对称边界&lt;/li&gt;
&lt;li&gt;如果有对称的结果，我们能够确定最小的对称长度就是：对称点的对称长度和当前点到对称边界的长度&lt;/li&gt;
&lt;li&gt;利用中心扩展，对于已知的对称长度，我们可以直接扩展到指定位置，无需重复计算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这三点，我们已经能够解答提出的疑问。但是还有一个问题，那就是用什么数据结构去描述这个对称结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;臂长&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如无必要，勿增实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据奥卡姆剃刀原则，我们最后的结果实际上只和中心扩展的位置相关，只需要一个数据，无需关心具体的字符。其次，利用空插字符后，始终是进行奇串的中心匹配。&lt;/p&gt;
&lt;p&gt;由此，&lt;code&gt;臂长&lt;/code&gt;这个概念应运而生，关于中心点左右对称，单边长度即为&lt;code&gt;臂长&lt;/code&gt;，回文长度就是两倍的臂长加上作为中心字符的长度。&lt;/p&gt;
&lt;p&gt;至此，我们思考并收集了解题的全部要素。&lt;/p&gt;
&lt;h3 id=&#34;马拉车&#34;&gt;马拉车&lt;/h3&gt;
&lt;p&gt;前面的思路全部聚集，就是大名鼎鼎的&lt;a href=&#34;https://baike.baidu.com/item/Manachar%E7%AE%97%E6%B3%95/20415813?fr=aladdin&#34;&gt;Manachar算法&lt;/a&gt;，小名 &lt;code&gt;马拉车&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要分析一下它的复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为要记住已经计算过的臂长的集合，总的就会有&lt;code&gt;N&lt;/code&gt;个元素，&lt;code&gt;O(N)&lt;/code&gt;空间必不可少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要提前申明的是，中心扩展是同时向两边扩展的，如果单边的长度是&lt;code&gt;N&lt;/code&gt;，总数据长度是&lt;code&gt;2N+1&lt;/code&gt;，但是复杂度依旧是&lt;code&gt;O(N)&lt;/code&gt;。因此这里只讨论单向扩展的问题。对于没有计算过的数据，首次计算他会拓展已经记录的右边界。如果对于已经计算过的对称字符内部，可以复用对称边界内的结果，直接推到边界点开始扩展。&lt;/p&gt;
&lt;p&gt;因此，数据的每次扩展，都只会在边界外进行扩展，也就是说，时间复杂度是&lt;code&gt;O(N)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::fill(s);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; arms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; chars.len()];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;chars.len() {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界内
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; current {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; min_arm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(arms[mirror], right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current);
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; min_arm, current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; min_arm);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current, current);
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; right {
                center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current];
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; arms[current];
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界 + 空插字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 空插
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 中心扩展
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 计算臂长
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arm&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::expand(arr, left, right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
    }
      
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;平心静气&#34;&gt;平心静气&lt;/h2&gt;
&lt;p&gt;仔细研读之后，在细细思索，整理出其中思路不难，整理出自己的思路不难。&lt;/p&gt;
&lt;p&gt;面对问题，主要的是分析，依据自身积累的储备，从各方面和角度进行详细的分析，寻求突破。&lt;/p&gt;
&lt;p&gt;可以不会，但是要学会积累。积累到一定程度，就能够解决一些未知但是可以已知的问题了。要保持思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 04 Jun 2023 22:46:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;最长回文子串httpsleetcodecnproblemslongest-palindromic-substring&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-palindromic-substring/&#34;&gt;最长回文子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;babad&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;bab&amp;rdquo;&lt;/li&gt;
&lt;li&gt;解释：&amp;ldquo;aba&amp;rdquo; 同样是符合题意的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;看到这种类似数组的东西，可能第一想法已经是&lt;code&gt;滑动窗口&lt;/code&gt;一类的了，但是仔细想一下，因为是&lt;code&gt;字符串&lt;/code&gt;，我们可能要重复扫描，滑动窗后就不行了。但是对于复用原来计算结果的&lt;code&gt;关系传递&lt;/code&gt;，我们还是可以利用的，这就诞生了第一种解法。&lt;/p&gt;
&lt;h3 id=&#34;dp&#34;&gt;dp&lt;/h3&gt;
&lt;p&gt;因为不可能一次性扫描，为了复用结果而采用&lt;code&gt;dp&lt;/code&gt;，我们可以轻易的得出如下结论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr[i][i]&lt;/code&gt; 单字符串必然是回文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i] == arr[j]&lt;/code&gt;那么，关键就看&lt;code&gt;arr[i+1]&lt;/code&gt;和&lt;code&gt;arr[j-1]&lt;/code&gt;，如果&lt;code&gt;i + 1 = j&lt;/code&gt;，也是回文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的递推关系出现了，但是问题才刚开始：长字符串始终是依赖短字符串的结果的，那么怎么开始遍历呢。&lt;/p&gt;
&lt;p&gt;我们的递推关系式固然是根据子串的边界，但是需要从小的字符串优先计算，因此，必须使用特殊的遍历技巧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; string_length]).collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; sub_length &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; string_length {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[right] {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[left&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                    max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sub_length;
                    begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
                }
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;遍历检测&#34;&gt;遍历检测&lt;/h3&gt;
&lt;p&gt;为什么我们总是去想到一些奇淫技巧呢，可能对于算法题，我们总是感觉有一种&lt;code&gt;技巧性&lt;/code&gt;在里面，否则就无法解题，至少效率不是很高。但是我们在原来的&lt;code&gt;dp&lt;/code&gt;基础上，直接解题会怎么样，我们直接定一个中心，然后向两边进行扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历字符串，定中心&lt;/li&gt;
&lt;li&gt;检测回文，计算结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这似乎更简单，我们尝试一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// spae: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; arr[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; arr[right] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; center &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; odd_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; event_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(odd_length, event_length);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center_length;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (center_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然是笨办法，但是在同等时间复杂度下，不需要借助额外的辅助空间也能够达成目的。也就是说，对于递推类问题，维护关系式第一要素，但是无法做到滑动窗口那种对于元素的一次性计算，有可能还会造成空间的浪费。&lt;/p&gt;
&lt;h2 id=&#34;马拉车&#34;&gt;马拉车&lt;/h2&gt;
&lt;p&gt;明天马拉车，代办&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数2</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</link>
      <pubDate>Fri, 02 Jun 2023 20:51:49 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</guid>
      <description>&lt;h2 id=&#34;紧跟上文&#34;&gt;紧跟上文&lt;/h2&gt;
&lt;p&gt;紧跟上文&lt;a href=&#34;https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;，在二分之后，继续深入。&lt;/p&gt;
&lt;h2 id=&#34;原理分析&#34;&gt;原理分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;中位数: 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的分析可以从&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&#34;&gt;官网解析&lt;/a&gt;找到详细的论述，我这里就不多费唇舌。&lt;/p&gt;
&lt;p&gt;结论就是，针对数组&lt;code&gt;a&lt;/code&gt;选取坐标&lt;code&gt;i&lt;/code&gt;，对于数组&lt;code&gt;b&lt;/code&gt;选取坐标&lt;code&gt;j&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt; : &lt;code&gt;a[0..i] + b[0..j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt; : &lt;code&gt;a[i..] + b[j..]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max(left) &amp;lt;= min(right)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt; a_len, 0 &amp;lt;= j &amp;lt; b_len, i + j = (a_len + b_len + 1) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 i + j 公式来自于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总长偶数: &lt;code&gt;left.len == right.len&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总长奇数: &lt;code&gt;left.len = right.len + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，换算成等式关系之后，我们只需要检索其中一个数组之后，就可以得出结论了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(min(M, N)))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(a: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#75715e&#34;&gt;// 始终保证 a 长度小于 b
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; b_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::find_median_sorted_arrays(b, a);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, a_len);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_max, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_min) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 检索
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分检索 i
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 计算对应的 j 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i;
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i-1] 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j-1]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// 满足条件，非最大 i ,向右查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; b_j {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 左侧数组的最大值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                a_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::max(a_i_prev, b_j_prev);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 右侧数组的最小值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                b_min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_i, b_j);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向右推进
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { 
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向左查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 左侧 多收容，中位数就是左侧最大数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            a_max &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 双边界平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            (a_max &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_min) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;降维打击&#34;&gt;降维打击&lt;/h2&gt;
&lt;p&gt;看完之后，只能说要常复习，常练习，只能看懂却不能掌握，实在太遗憾。&lt;/p&gt;
&lt;p&gt;同时，有两个启发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另辟蹊径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题中，从另一个角度去分析题目，把一道&lt;code&gt;搜索题&lt;/code&gt;变成了一道&lt;code&gt;计算题&lt;/code&gt;。虽然还是有搜索的部分，但是更偏向于&lt;code&gt;计算+匹配&lt;/code&gt;了，比起之前的简单计算+复杂搜索，把搜索的复杂度，向计算过度，从而达到足够优化的算法复杂度；进一步对原有的实现方法形成降维打击。&lt;/p&gt;
&lt;p&gt;一方面，可以说是思维的精妙。一般时间复杂度的降低，除了大量空间的牺牲可以提高，剩下的只能够凭借精妙的算法得以达成。&lt;/p&gt;
&lt;p&gt;另一方面，则是思维上的开拓。不仅仅是对于思维的跳脱，还需要有开阔的眼界，否则，何来的素材；多积累才有的多选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系传导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多事情，哪怕算法，只有抓到核心关键，才能够事半功倍。正如斐波那契，正如汉诺塔。如果只是一昧的暴力，总有碰壁的时候。同样是规律，越是接近事物的本质，效率也来的更加的快速；刨除了无用的损耗，效率自然成倍的提高。&lt;/p&gt;
&lt;p&gt;越来越相信大道至简，因为越是了解越多，越是接近本质，如此的简单，威力却如此的巨大。降维打击，莫过如此。&lt;/p&gt;
&lt;p&gt;的确，如果真的想要时时顺心，事事如意，我们必须要提高我们的效率，去达成面临的事情；但是面临的事情逐渐的庞大，我们的效率不能只是&lt;code&gt;速度&lt;/code&gt;，还要有&lt;code&gt;质量&lt;/code&gt;，快速的，摧枯拉朽的去解决掉阻碍的事情，这才是我们需要积累的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Thu, 01 Jun 2023 22:51:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度应该为 O(log (m+n)) 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums1 = [1,3], nums2 = [2]&lt;/li&gt;
&lt;li&gt;输出：2.00000&lt;/li&gt;
&lt;li&gt;解释：合并数组 = [1,2,3] ，中位数 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;数组的中位数，值的一提的就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组长度是奇数，中位数就是有序数组的最中间的值&lt;/li&gt;
&lt;li&gt;如果数组长度是偶数，中位数就是有序数组中间两个值的平均&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算过程中，假设排序数组为&lt;code&gt;arr&lt;/code&gt;，数据长度为&lt;code&gt;len&lt;/code&gt;，中位数表示如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组长度为奇数: &lt;code&gt;arr[len / 2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组长度为偶数: &lt;code&gt;(arr[len / 2] + arr[len / 2 + 1]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然是分支逻辑，但是通过特殊的计算，我们可以合并为相同的逻辑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(arr[(len + 1) / 2] + arr[(len + 2) / 2]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就能够更简单的进行问题的求解。&lt;/p&gt;
&lt;p&gt;本题目求解不难，难点在于&lt;code&gt;O(log(m + n))&lt;/code&gt;的时间复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于合并之后直接求解的办法已经说明，这里专注其他技巧求解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h3&gt;
&lt;p&gt;目前滑动窗口的出镜率极高，这道题也可用滑动窗口进行求解。并且和之前的&lt;code&gt;缓存&lt;/code&gt;有很大的区别，&lt;code&gt;窗口&lt;/code&gt;本身的概念也于抽象。&lt;/p&gt;
&lt;p&gt;其实找到中位数，并不一定需要合并到同一个数组，使用两个指针维护查找的队列，其实就可以达到同样的目的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M + N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nums1.len(), nums2.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_idx, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_idx) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; current, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums1[a_idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums2[b_idx] {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; ) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;二分法&#34;&gt;二分法&lt;/h3&gt;
&lt;p&gt;其实对于&lt;code&gt;O(log(m + n))&lt;/code&gt;的第一反应，必定就是二分法，关键在于如何构造二分。&lt;/p&gt;
&lt;p&gt;这里其实有一个很细微的理解问题，正如&lt;code&gt;三&lt;/code&gt;在古文中表示的意思是&lt;code&gt;多&lt;/code&gt;，而非真的是&lt;code&gt;3&lt;/code&gt;。所谓的二分法，并非严格意义上的丛中分断，它不仅可以是&lt;code&gt;1/n&lt;/code&gt;，甚至在一些边界条件中，也是允许不严格的划分的。尤其是其中的&lt;code&gt;O(log(m + n))&lt;/code&gt;，底数并没有固定展示，这只是一种表示方法，一种趋势，如果是&lt;code&gt;1/n&lt;/code&gt;分，底数不过就变成了&lt;code&gt;n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;说到这里，结合前面的方法，其实我们已经掌握了核心的办法，这要从两个问题进行引申&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是单个数组的话，直接通过计算就可以得出结果，但是我们为什么需要进行查找。查找其实只是为了区分两个数组之间的关系，而对于一个数组中的中位数，我们可以直接计算出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于滑动窗口的优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，边界情况下，只剩下了一个数组，我们可以直接进行计算，而非继续傻傻的一个个查找。但是为什么会到这一步呢，因为我们&lt;code&gt;排除&lt;/code&gt;了其中一些非法的答案。查找类的问题经常有两种办法进行求解，正向的匹配检查，和反向的非法排除。常用的二分法，其实就是在规则匹配的条件下对空间进行排除，并且排除优先于匹配。可能对于经典的二分法而言，每一步空间的缩小似乎都是正向的匹配，但其实排除大量的干扰，才是二分的要义。&lt;/p&gt;
&lt;p&gt;可能相较于单个数组的精准匹配，排除似乎更废时间；但是对于本题中类似的模糊区间查找，排除才是王道。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(m+n))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums2.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 两数平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, left) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, right)) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_nth&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, k: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_begin, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_begin) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 单边直接计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; b[b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;b_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a[a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cmp::min(a[a_begin], b[b_begin]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分移除： 因为对于half而言是可以稳定移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; half &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界条件下非二分移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, a_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 降低 k 缩小边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a[next_a_begin] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; b[next_b_begin] {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二分之所以威力巨大，其实是因为它只用判断一半的元素，正如我们查找中位数，正向查找完全不好关心后半截的数据一样。&lt;/p&gt;
&lt;h3 id=&#34;反向排除&#34;&gt;反向排除&lt;/h3&gt;
&lt;p&gt;在迷茫的时候，缺乏正确的指引，盲目的追求正确，试错成本很高，而且可能要经受多次的失败。但如果是深思熟虑，通过少数的关键特征，些许的试错然后去排除错误的选项，这就能让我们更快，更有效的找到正确的选项。&lt;/p&gt;
&lt;p&gt;学习算法，学会高效的处理的方式，同样可以使用于人生。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串</title>
      <link>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 31 May 2023 23:04:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&#34;&gt;无重复字符的最长子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: s = &amp;ldquo;abcabcbb&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;li&gt;解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;对于这种基础的题目，爆破始终是第一选项。如果有过更近一步的经验，感觉也能和递推产生一些关系。但是首选项必然是&lt;code&gt;滑动窗口&lt;/code&gt;。
&lt;code&gt;滑动窗口&lt;/code&gt;其实没有什么高深的原理，只是维护一个动态的窗口条件，通过边界的缩放，判断、修改窗口内的数据关系。不过是看起来像窗口而已，我更宁愿把它归纳为之前提炼出来的&lt;code&gt;关系传导&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然是使用&lt;code&gt;缓存&lt;/code&gt;的，但是这所谓缓存的结果，隐含了之前计算的元素之间的微妙联系。滑动窗口也是如此，它通过窗口边界的收缩，把某种关系限定在窗口数据内，当我们进行新一轮的判断的时候，&lt;code&gt;关系&lt;/code&gt;的传导让我们不必关心更多的干扰，从而去针对的制定逻辑。把纷繁的问题逐步拆分，这样就使得求解变得简单、清晰。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) 需要遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(X) 字符集长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashSet;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;length_of_longest_substring&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; container &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashSet::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[right];
            &lt;span style=&#34;color:#75715e&#34;&gt;// 剔除重复字符串
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; container.contains(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[left];
                container.remove(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;left_char);
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 窗口内有效字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            container.insert(ch);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; container.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; container.len();
            }
        }
        res &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基础维护&#34;&gt;基础维护&lt;/h2&gt;
&lt;p&gt;我们为什么需要学习，因为我们想具备某种能力，从而让自己变得更加的自由。&lt;/p&gt;
&lt;p&gt;这里隐含了一种关系，&lt;code&gt;维护&lt;/code&gt;和&lt;code&gt;使用&lt;/code&gt;。学习红黑树的时候，让我十分厌倦；不论是各种旋转还是条件、染色，只是让我觉得啰嗦。我觉得学习这种东西，除了应付差事，我大概永远和它无缘。后面知晓数据库使用了树结构，其实我也有一种想法，觉得数据库简直多余。的确，&lt;code&gt;维护&lt;/code&gt;是无用的，耗时且费力的，默默无闻一辈子，可能光辉的一瞬都不一定能换回来。&lt;/p&gt;
&lt;p&gt;但是，俗话说得好，&lt;code&gt;一口吃不成&lt;/code&gt;胖子。想要成为胖子，那是需要&lt;code&gt;日积月累&lt;/code&gt;的，&lt;code&gt;水滴石穿，非一日之功&lt;/code&gt;。面对一些事情，我们的能力，我们的选择，并不能&lt;code&gt;一蹴而就&lt;/code&gt;。正如使用数据库，尽管实现很麻烦，使用&lt;code&gt;SQL&lt;/code&gt;也不简单，但是面对海量的数据的时候，我们能够轻易的完成查找、聚合、排序等操作。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。显而易见的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比起瞬间聚集的能力，维护是小步的、简单的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;我这一拳二十年的功力，你挡得住么&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;正如扭螺丝的奇葩账单，有些简单的事情背后真的很不简单。为什么不同岗位的工资差别如此的巨大，仅仅是因为工作内容的不一致么。并不是，而是来源于工作能力的培养难度。学了二十年才能出师的岗位，显然比学习一周上岗的岗位薪酬高的多。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。短小的时日并不能集聚太多的知识。&lt;/p&gt;
&lt;p&gt;这也正是要专心写博客的原因，没有之一。你想有的能力，需要维护。维护的多好，当你使用的时候就能发挥多大的效果。比起完成瞬间积聚巨大能量的不可能，水滴石穿、细水长流的积累，显得如此的轻松。请放心，付出终究会有收获，如果每一份耕耘都太过艰难，那只是预示你将会有巨大的丰收。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数相加</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Tue, 30 May 2023 22:55:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>&lt;h2 id=&#34;两数相加httpsleetcodecnproblemsadd-two-numbers&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/add-two-numbers/&#34;&gt;两数相加&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：l1 = [2,4,3], l2 = [5,6,4]&lt;/li&gt;
&lt;li&gt;输出：[7,0,8]&lt;/li&gt;
&lt;li&gt;解释：342 + 465 = 807.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;逐位相加，算是最简单的办法了；当然，也可以转换成数字后相加，但是如果数据溢出，也会有问题。&lt;/p&gt;
&lt;p&gt;本题最关键的，就是如何计算&lt;code&gt;进位&lt;/code&gt;。当然，谁都能看出来，但是最关键有如下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位数补齐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果其中一个链表用完了该怎么办呢，可能大多数人直接反应就是将后续的列表进行拼接，容易忽略进位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算出的结果也不一定就是和最大输入同长度的，额外的进位需要再后面进行补足。&lt;/p&gt;
&lt;p&gt;和上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/&#34;&gt;两数之和&lt;/a&gt;一样，所谓进位，也可以算得上一种关系的固化和传递，虽然很浅显，但是需要继续保有这种意识，才能逐步加深认知，才能敏锐的发现一些相似的东西。&lt;/p&gt;
&lt;h3 id=&#34;原始解题&#34;&gt;原始解题&lt;/h3&gt;
&lt;p&gt;先用最简单的办法实现一遍。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; l1.is_some() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; l2.is_some() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l1.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.unwrap();
                a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l2.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2.unwrap();
                b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        }
        res
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l1, l2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// (list1, list2, sum, carry)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; data {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 无数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;,
                &lt;span style=&#34;color:#75715e&#34;&gt;// 直接进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; (None, None, carry, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;),
                &lt;span style=&#34;color:#75715e&#34;&gt;// 其中一个有数据，且能进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(list), None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(list), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (list.next, None, sum, c)
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 两个数进位加法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(l1), Some(l2), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; l2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (l1.next, l2.next, sum, c)
                }
            };

            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(data.&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        res
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;递归处理&#34;&gt;递归处理&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        Self::add_two_numbers_recursive(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, last, l1, l2);
        res
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers_recursive&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, last: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (l1, l2, carry) {
            (None, None, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))),
            (Some(node), None, _) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(node), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node.next, None);
            },
            (Some(node1), Some(node2), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; node2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node1.next, node2.next);
            },
            _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {}
            
        }  
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;优化处理&#34;&gt;优化处理&lt;/h2&gt;
&lt;p&gt;关于这个问题的主体，还是在&lt;code&gt;进位&lt;/code&gt;的计算，不论是只剩下单边数据了还能继续进位，还是说溢出产生的额外进位。&lt;/p&gt;
&lt;p&gt;虽然问题的核心得到了解决，不过还有几个方面让我们的方案变得更好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面虽然说了即使单边数据也能连续进位，但是对于不可进位的单边数据，可以采取直接嫁接的方法，提前结束判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原地相加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以不利用额外的数据结构，直接以单边数据为容器进行相加。不过这种方式还是避免不了进位溢出和选取了数据较短的一方，空间复杂度还是一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数之和</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 29 May 2023 23:31:46 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;两数之和httpsleetcodecnproblemstwo-sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/two-sum/&#34;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标值 &lt;code&gt;target&lt;/code&gt;  的那两个整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [2,7,11,15], target = 9&lt;/li&gt;
&lt;li&gt;输出：[0,1]&lt;/li&gt;
&lt;li&gt;解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;h3 id=&#34;爆破&#34;&gt;爆破&lt;/h3&gt;
&lt;p&gt;对于这道题，粗暴的求解方式就是对于数组中的的两两组合求值，从而判断结果是否符合答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2) : 最坏情况需要遍历全部可能配对
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)  : 无额外空间消耗
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; , j &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;];
                }
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;按图索骥&#34;&gt;按图索骥&lt;/h3&gt;
&lt;p&gt;这里有两个特殊的视角&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于确定等式的三个数值，我们只要确定了其中两个，就能够唯一确定第三个&lt;/li&gt;
&lt;li&gt;可以列一个清单去进行匹配，而不是每次都需要重新计算(缓存)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质的核心，其实就是等式关系的延续，把一个&lt;code&gt;满足等式的数&lt;/code&gt;的判断，转化为&lt;code&gt;某个确定的数&lt;/code&gt;的限定条件。&lt;!-- raw HTML omitted --&gt;
更关键的是，对于&lt;code&gt;target&lt;/code&gt;和&lt;code&gt;nums[?]&lt;/code&gt;的依赖，做了一个特殊的持久化，不用每次计算都携带，降低了信息传递的消耗。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) : 只用遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N) : 最坏情况首尾相加
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; last.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![last.unwrap().to_owned(), index];
            }
            map.insert(target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; value, index);
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关键技巧&#34;&gt;关键技巧&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;缓存&lt;/code&gt;固然是一个关键的技巧，但是我更宁愿把&lt;code&gt;固化&lt;/code&gt;称为其中核心秘籍。&lt;/p&gt;
&lt;p&gt;正是因为&lt;code&gt;固化&lt;/code&gt;了其中的计算关系，&lt;code&gt;缓存&lt;/code&gt;才能发挥更大的能力。
所谓&lt;code&gt;缓存&lt;/code&gt;，其实就是耗费资源去得到的一个结果，当我们重复的去获取这个结果的时候，使用已经计算好的副本，能够极大的避免计算的开销。
因此，在涉及重复计算的场景下，缓存有很大的作用空间；但是，&lt;code&gt;固化&lt;/code&gt;作为其核心要义，并非只是简单的存储结果。
一个计算结果本身就有来由的原因。&lt;/p&gt;
&lt;p&gt;本题中，正式因为把算式的因果关系转换，并且利用缓存进行&lt;code&gt;固化&lt;/code&gt;，把查找转换为匹配，才根源上完成解题的突破。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>just-worker</title>
    <link>https://just-worker.github.io/</link>
    <description>Recent content on just-worker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Tue, 04 Jul 2023 23:26:01 +0800</lastBuildDate><atom:link href="https://just-worker.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>螺旋矩阵</title>
      <link>https://just-worker.github.io/blog/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Tue, 04 Jul 2023 23:26:01 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>&lt;h2 id=&#34;螺旋矩阵httpsleetcodecnproblemsspiral-matrix&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/spiral-matrix/&#34;&gt;螺旋矩阵&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]&lt;/li&gt;
&lt;li&gt;输出：[1,2,3,6,9,8,7,4,5]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]&lt;/li&gt;
&lt;li&gt;输出：[1,2,3,4,8,12,11,10,9,5,6,7]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;整体无非就是按照&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺序进行访问，当无法沿着单一方向进行访问的时候，就顺序切换方向，没有访问过的元素。&lt;/p&gt;
&lt;h3 id=&#34;是否访问&#34;&gt;是否访问&lt;/h3&gt;
&lt;p&gt;根据上述想法，我们可以构造一个二维布尔数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果下一个数值没有访问过，我们就沿着单一方向进行访问&lt;/li&gt;
&lt;li&gt;如果下一个数值已经访问过，切换方向判断下一个数据&lt;/li&gt;
&lt;li&gt;如果切换方向后还是已经访问，结束；否则，沿着下一个方向继续访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码就不写了，时间复杂度&lt;code&gt;O(MN)&lt;/code&gt;，空间复杂度&lt;code&gt;O(MN)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;边界限制&#34;&gt;边界限制&lt;/h3&gt;
&lt;p&gt;不使用访问标记，直接限定边界进行访问，可以看做剥洋葱一样，层层解套。&lt;/p&gt;
&lt;p&gt;再次深入分析结束的时机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt;: 最后只剩下单行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;down&lt;/code&gt;: 最后剩下单列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt;: 无中心，刚好闭环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是因为&lt;code&gt;right&lt;/code&gt;和&lt;code&gt;down&lt;/code&gt;有边界的限制，边界不符合的情况无法进行遍历，因此我们可以结束时机统一的挂在&lt;code&gt;down&lt;/code&gt;遍历之后。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;spiral_order&lt;/span&gt;(matrix: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; matrix[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].clone();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;r).into_iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;matrix[i][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]).collect();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x_1, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x_2, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; y_1, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; y_2) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, c &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; x_1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x_2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; y_1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; y_2 {
            &lt;span style=&#34;color:#75715e&#34;&gt;// right
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; y_1&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;y_2 {
                res.push(matrix[x_1][y]);
            }
            x_1 &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// down
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; x_1&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;x_2 {
                res.push(matrix[x][y_2]);
            }
            y_2 &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界超出，遍历终止
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x_1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x_2 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; y_1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; y_2 {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// left
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (y_1&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;y_2).rev() {
                res.push(matrix[x_2][y]);
            }
            x_2 &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// up
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (x_1&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;x_2).rev() {
                res.push(matrix[x][y_1]);
            }
            y_1 &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>最大子数组和</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</link>
      <pubDate>Mon, 03 Jul 2023 23:03:52 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;最大子数组和httpsleetcodecnproblemsmaximum-subarray&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/maximum-subarray/&#34;&gt;最大子数组和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;子数组 是数组中的一个连续部分&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/li&gt;
&lt;li&gt;输出：6&lt;/li&gt;
&lt;li&gt;解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;核心问题在哪呢，除了初始值的设置外，和累加的过程中需要注意两种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能跳过，每个数据都必须进行操作&lt;/li&gt;
&lt;li&gt;如果累加有收益，就进行累加，否则从当前数值重新进行累加&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后进行最大值判断即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max_sub_array&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 选取收益最大的值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[i], nums[i]);
            &lt;span style=&#34;color:#75715e&#34;&gt;// 记录最大值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(sum, res);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>N皇后II</title>
      <link>https://just-worker.github.io/blog/n%E7%9A%87%E5%90%8Eii/</link>
      <pubDate>Mon, 03 Jul 2023 22:58:35 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/n%E7%9A%87%E5%90%8Eii/</guid>
      <description>&lt;h2 id=&#34;n皇后iihttpsleetcodecnproblemsn-queens-ii&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/n-queens-ii/&#34;&gt;N皇后II&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/11/13/queens.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：n = 4&lt;/li&gt;
&lt;li&gt;输出：2&lt;/li&gt;
&lt;li&gt;解释：如上图所示，4 皇后问题存在两个不同的解法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;和前一篇一致，废话不多说&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;total_n_queens&lt;/span&gt;(n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; used &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; n &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;]; n &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;];
        Self::dfs(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; used, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, used: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, level: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; used.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; level &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; len {
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::check(used, level, i) {
                used[level][i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                Self::dfs(res, used, level &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
                used[level][i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
        }
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt;(used: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, r: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, c: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; used.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 列
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; used[line][c] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; r {
                line &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; line
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// 斜线
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; used[line][delta &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            } 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; used[line][c &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; delta] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>N皇后</title>
      <link>https://just-worker.github.io/blog/n%E7%9A%87%E5%90%8E/</link>
      <pubDate>Mon, 03 Jul 2023 22:48:44 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/n%E7%9A%87%E5%90%8E/</guid>
      <description>&lt;h2 id=&#34;n皇后httpsleetcodecnproblemsn-queens&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/n-queens/&#34;&gt;N皇后&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。&lt;/p&gt;
&lt;p&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。&lt;/p&gt;
&lt;p&gt;每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &amp;lsquo;Q&amp;rsquo; 和 &amp;lsquo;.&amp;rsquo; 分别代表了皇后和空位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/11/13/queens.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：n = 4&lt;/li&gt;
&lt;li&gt;输出：[[&amp;quot;.Q..&amp;quot;,&amp;quot;&amp;hellip;Q&amp;quot;,&amp;ldquo;Q&amp;hellip;&amp;rdquo;,&amp;quot;..Q.&amp;quot;],[&amp;quot;..Q.&amp;quot;,&amp;ldquo;Q&amp;hellip;&amp;rdquo;,&amp;quot;&amp;hellip;Q&amp;quot;,&amp;quot;.Q..&amp;quot;]]&lt;/li&gt;
&lt;li&gt;解释：如上图所示，4 皇后问题存在两个不同的解法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;爆破&#34;&gt;爆破&lt;/h2&gt;
&lt;p&gt;爆破是必然的，但是怎么递归是个问题。&lt;/p&gt;
&lt;p&gt;首先必须明确一点的是，爆破，其实就是不停地试数据，进一步的试数据，然后恢复现场试下一次数据。&lt;/p&gt;
&lt;p&gt;因此，对于这种题目，我们可以总结如下步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建完成的答案结构，不保证内容正确&lt;/li&gt;
&lt;li&gt;构建数据合规检查，方便下一次试数据和提前返回&lt;/li&gt;
&lt;li&gt;填写本次数据，尝试下一轮试数，恢复现场&lt;/li&gt;
&lt;li&gt;试到最后一个说明符合条件，添加到答案&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本次的问题点在于第四点，如何构建合规检查；这里先解释一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行不重复：每行只试一次，天然保证&lt;/li&gt;
&lt;li&gt;每列不重复：遍历同列检查&lt;/li&gt;
&lt;li&gt;斜线不重复：可以发现，行上面的偏移&lt;code&gt;offset&lt;/code&gt;等于列&lt;code&gt;column&lt;/code&gt;上面的偏移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们的解题步骤大概如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建答案结构：这里为了方便使用二维布尔数组，方便过程检查，添加答案时候生成标准结构&lt;/li&gt;
&lt;li&gt;合规逻辑如上&lt;/li&gt;
&lt;li&gt;同规则&lt;/li&gt;
&lt;li&gt;生成答案&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solve_n_queens&lt;/span&gt;(n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; used &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; n &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;]; n &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;];
        Self::dfs(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; used, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, used: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, level: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; used.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; level &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; len {
            res.push(used.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Q&amp;#39;&lt;/span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;}).collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;()).collect());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::check(used, level, i) {
                used[level][i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                Self::dfs(res, used, level &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
                used[level][i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
        }
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt;(used: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, r: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, c: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; used.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 列
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; used[line][c] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; r {
                line &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; line
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// 斜线
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; used[line][delta &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            } 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; used[line][c &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; delta] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Pow</title>
      <link>https://just-worker.github.io/blog/pow/</link>
      <pubDate>Fri, 30 Jun 2023 21:35:04 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/pow/</guid>
      <description>&lt;h2 id=&#34;powx-nhttpsleetcodecnproblemspowx-n&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/powx-n/&#34;&gt;Pow(x, n)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;注意折半计算，主要是递归太深入，使用额外变量进行存储奇数增生的数值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(logN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// n 是 i32, 直接反向可能溢出
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;my_pow&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;{
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, rev) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (x, n, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
                res &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; x;
            }
            x &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; x;
            n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; rev {&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; res} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {res};
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>字母异位词分组</title>
      <link>https://just-worker.github.io/blog/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</link>
      <pubDate>Fri, 30 Jun 2023 21:13:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</guid>
      <description>&lt;h2 id=&#34;字母异位词分组httpsleetcodecnproblemsgroup-anagrams&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/group-anagrams/&#34;&gt;字母异位词分组&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。&lt;/p&gt;
&lt;p&gt;字母异位词 是由重新排列源单词的所有字母得到的一个新单词。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: strs = [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;输出: [[&amp;ldquo;bat&amp;rdquo;],[&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;],[&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;把字符排序即可&lt;/li&gt;
&lt;li&gt;字符统计后按照顺序计数作为唯一key &lt;code&gt;a1b2c4&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;group_anagrams&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::collections::HashMap::new();
        &lt;span style=&#34;color:#75715e&#34;&gt;// 字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        strs.into_iter().for_each(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 计数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;];
            s.bytes().for_each(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; counter[(v &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&amp;#39;a&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#75715e&#34;&gt;// 分组
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            map.entry(counter).or_insert(vec![]).push(s);
        });
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; map.values().cloned().collect();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>旋转图像</title>
      <link>https://just-worker.github.io/blog/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Fri, 30 Jun 2023 20:56:57 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
      <description>&lt;h2 id=&#34;旋转图像httpsleetcodecnproblemsrotate-image&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/rotate-image/&#34;&gt;旋转图像&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg&#34; alt=&#34;&#34;&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;额外空间很简单，不用多说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;手动旋转&#34;&gt;手动旋转&lt;/h3&gt;
&lt;p&gt;考虑单行是怎么进行旋转的，对应的位置如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;top&lt;/code&gt;: &lt;code&gt;matrix[r][c]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt;: &lt;code&gt;matric[c][len - 1 - r]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bottom&lt;/code&gt;: &lt;code&gt;matric[len - 1 - r][len - 1 - c]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt;: &lt;code&gt;matric[len - 1 - c][r]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一圈一圈的进行收缩遍历即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N ^ 2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rotate&lt;/span&gt;(matrix: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left_top, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right_bottom) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; r, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; v) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left_top &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right_bottom {
            r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left_top;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; left_top&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;right_bottom {
                v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[r][c];
                &lt;span style=&#34;color:#75715e&#34;&gt;// left -&amp;gt; top
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                matrix[r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c][r];
                &lt;span style=&#34;color:#75715e&#34;&gt;// bottom -&amp;gt; left
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c][r] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r][len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c];
                &lt;span style=&#34;color:#75715e&#34;&gt;// right -&amp;gt; bottom
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r][len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[c][len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r];
                &lt;span style=&#34;color:#75715e&#34;&gt;// top -&amp;gt; right
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                matrix[c][len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
            }
            left_top &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right_bottom &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;特殊旋转&#34;&gt;特殊旋转&lt;/h3&gt;
&lt;p&gt;顺时针90旋转 = 水平反转 + 角对称&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N ^ 2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rotate&lt;/span&gt;(matrix: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 水平翻转
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; r &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[r][c];
                matrix[r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r][c];
                matrix[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 角对称
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; r &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;r {
                v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[r][c];
                matrix[r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; matrix[c][r];
                matrix[c][r] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>全排列II</title>
      <link>https://just-worker.github.io/blog/%E5%85%A8%E6%8E%92%E5%88%97ii/</link>
      <pubDate>Thu, 29 Jun 2023 22:54:00 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%85%A8%E6%8E%92%E5%88%97ii/</guid>
      <description>&lt;h2 id=&#34;全排列iihttpsleetcodecnproblemspermutations-ii&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/permutations-ii/&#34;&gt;全排列II&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [1,1,2]&lt;/li&gt;
&lt;li&gt;输出：
[[1,1,2],
[1,2,1],
[2,1,1]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;和&lt;a href=&#34;https://just-worker.github.io/blog/%E5%85%A8%E6%8E%92%E5%88%97/&#34;&gt;上一题&lt;/a&gt;类似，但是要求不重复。&lt;/p&gt;
&lt;p&gt;目前已经遇到过很多类似的要求，固然可以通过&lt;code&gt;set&lt;/code&gt;进行去重，但是凭空增加了无谓的消耗，这点需要时刻注意。&lt;/p&gt;
&lt;p&gt;之所以会产生重复的序列，主要在于其中的重复数字。我们应该如何去控制这些重复的数呢。&lt;/p&gt;
&lt;p&gt;前面的&lt;a href=&#34;https://just-worker.github.io/blog/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/&#34;&gt;这道题&lt;/a&gt;给了我们一些灵感，可以统计频次，控制使用数量。&lt;/p&gt;
&lt;p&gt;不过这还是不对，重复的序列固然是因为数值的重复，但还有重复数值之间的顺序，如果只是保证了数量，并不能够完全的做到不重复。&lt;/p&gt;
&lt;p&gt;使用数值的时候，我们应该立下如下两个规矩，才能达成目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能重复使用数据&lt;/li&gt;
&lt;li&gt;必须依次使用数据，不能跳过&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N x N!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;permute_unique&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        nums.sort();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        Self::generate(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; vec![], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; len], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate&lt;/span&gt;(collect: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, used: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums.len() {
            res.push(collect.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v).collect());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 使用过的不能再使用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 只能依次使用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; used[i] &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;used[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            }
            used[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            collect.push(nums[i]);
            Self::generate(collect, nums, res, used, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            used[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            collect.pop();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>全排列</title>
      <link>https://just-worker.github.io/blog/%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 28 Jun 2023 22:29:25 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>&lt;h2 id=&#34;全排列httpsleetcodecnproblemspermutations&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/permutations/&#34;&gt;全排列&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [1,2,3]&lt;/li&gt;
&lt;li&gt;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;就是挨个试数据，然后进行组合。这里肯定用回溯，但唯一的问题是，怎么区分已用过和未用过的数据。&lt;/p&gt;
&lt;p&gt;这里可以直接使用一个数组，用&lt;code&gt;idx&lt;/code&gt;进行标记，这里有双重含义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;idx&lt;/code&gt;表示需要尝试进行随机替换的数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idx&lt;/code&gt;之前的数字就是已经用过的数字&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time： O(N x N!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;permute&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        Self::generate(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;

    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate&lt;/span&gt;(res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, idx: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// 生成完毕，添加
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums.len() {
            res.push(nums.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v).collect());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 分别使用后续的数字替换当前位置的数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; idx&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            nums.swap(idx, i);
            Self::generate(res, nums, idx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            nums.swap(idx, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;回溯感想&#34;&gt;回溯感想&lt;/h2&gt;
&lt;p&gt;使用递推、回溯进行解题，一定要有想象力，甚至是幼稚、废话的因果提取。&lt;/p&gt;
&lt;p&gt;虽然似乎天马行空，但是因果的层层累积，就能够抵达彼岸。&lt;/p&gt;
&lt;p&gt;不用追究细节，只要能够在因果内闭环即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>跳跃游戏II</title>
      <link>https://just-worker.github.io/blog/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Tue, 27 Jun 2023 22:55:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</guid>
      <description>&lt;h2 id=&#34;跳跃游戏iihttpsleetcodecnproblemsjump-game-ii&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/jump-game-ii/&#34;&gt;跳跃游戏II&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。&lt;/p&gt;
&lt;p&gt;每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= j &amp;lt;= nums[i] &lt;/li&gt;
&lt;li&gt;i + j &amp;lt; n&lt;/li&gt;
&lt;li&gt;返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: nums = [2,3,1,1,4]&lt;/li&gt;
&lt;li&gt;输出: 2&lt;/li&gt;
&lt;li&gt;解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;h3 id=&#34;直接爆破&#34;&gt;直接爆破&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;jump&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;; len];
        dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;nums[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len {
                    dp[i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(dp[i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j], &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dp[i]);
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;反向查找&#34;&gt;反向查找&lt;/h3&gt;
&lt;p&gt;从最后开始算，每次都反向调到最大的步子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;jump&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; steps &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;end {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; end {
                    end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
                    steps &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; steps;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;边界推进&#34;&gt;边界推进&lt;/h3&gt;
&lt;p&gt;反向的话，需要遍历之前的边界，而且没有记忆，能不能从正向进行计算呢。&lt;/p&gt;
&lt;p&gt;不过首先得厘清一个问题：正向是否能够&lt;code&gt;贪心&lt;/code&gt;的按照最大步子进行跳跃。&lt;/p&gt;
&lt;p&gt;答案是可以的，但原因却不是&lt;code&gt;贪心&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大步子跳过了最优解，但其实是可以跳到最优解的，且连续大步因为拆分需要&lt;code&gt;+1&lt;/code&gt;，两者是等价的&lt;/li&gt;
&lt;li&gt;根据前一条，每次按照最大步跳，到达边界逐步推进，因为自动兼容最优解，两者结果等价&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;jump&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (len, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; end, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_right, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; steps) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nums.len(), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#75715e&#34;&gt;// end &amp;gt;= i，大于的时候肯定会越过一步，等于的时候会再+1，因此不用考虑 len - 1 最后一步
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 最右边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            max_right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(max_right, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;);
            &lt;span style=&#34;color:#75715e&#34;&gt;// 到达边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; end {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 继续跳到最右边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_right;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 每次跳动+1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                steps &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; steps;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>通配符匹配</title>
      <link>https://just-worker.github.io/blog/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 26 Jun 2023 22:56:30 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</guid>
      <description>&lt;h2 id=&#34;通配符匹配httpsleetcodecnproblemswildcard-matching&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/wildcard-matching/&#34;&gt;通配符匹配&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 &amp;lsquo;?&amp;rsquo; 和 &amp;lsquo;&lt;em&gt;&amp;rsquo; 匹配规则的通配符匹配：
&amp;lsquo;?&amp;rsquo; 可以匹配任何单个字符。
&amp;lsquo;&lt;/em&gt;&amp;rsquo; 可以匹配任意字符序列（包括空字符序列）。
判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;*&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;li&gt;解释：&#39;*&#39; 可以匹配任意字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;当前是普通字符或者&lt;code&gt;?&lt;/code&gt;的时候，很简单，反正都是直接判断即可。&lt;/p&gt;
&lt;p&gt;如果当前是&lt;code&gt;*&lt;/code&gt;，只有两种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳过&lt;/li&gt;
&lt;li&gt;任意匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加上空字符串的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空字符串匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 匹配空字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_match&lt;/span&gt;(s: String, p: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (s, p) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (s.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;(), p.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (s_len, p_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (s.len(), p.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; p_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; s_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 空字符肯定匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// * 也可以匹配空字符串
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;p_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; p[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; {
                dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; si &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;s_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; pi &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;p_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; p[pi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// dp[si - 1][pi]: * 匹配其他字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;// dp[si][pi - 1]: * 不匹配字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[si][pi] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[si &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][pi] &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; dp[si][pi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; p[pi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; p[pi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; s[si &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 当前匹配，传播
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[si][pi] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[si &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][pi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[s_len][p_len]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>收假戒烟</title>
      <link>https://just-worker.github.io/blog/%E6%94%B6%E5%81%87%E6%88%92%E7%83%9F/</link>
      <pubDate>Sun, 25 Jun 2023 20:41:25 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%94%B6%E5%81%87%E6%88%92%E7%83%9F/</guid>
      <description>&lt;h2 id=&#34;端午戒烟&#34;&gt;端午戒烟&lt;/h2&gt;
&lt;p&gt;端午已经达成了三天一包，虽然在家里还是抽烟了，但是总的来说都在减少，而不是家里面不抽，外面狠抽。&lt;/p&gt;
&lt;p&gt;其实比较不确定的是收假的时候，因为收假第一天就是早班，起一大早，不太确定精神状态。&lt;/p&gt;
&lt;h2 id=&#34;收假吸烟&#34;&gt;收假吸烟&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;上班：1&lt;/li&gt;
&lt;li&gt;值班：1&lt;/li&gt;
&lt;li&gt;中午：1&lt;/li&gt;
&lt;li&gt;下午：1&lt;/li&gt;
&lt;li&gt;烦闷：1&lt;/li&gt;
&lt;li&gt;下班：1&lt;/li&gt;
&lt;li&gt;日记：1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天虽然值班，但还是控制在了预定范围内，虽然好像才克制了 1 ，但这个基准，肯定不是随便定的，只要控制在范围内，就是好的。&lt;/p&gt;
&lt;p&gt;回想之前值班，每小时下楼，每次 1~2 根，一天消耗实在巨大。&lt;/p&gt;
&lt;h2 id=&#34;今日小结&#34;&gt;今日小结&lt;/h2&gt;
&lt;p&gt;从细节上看，每次下楼强制只吸一根，打断萎靡状态，是很有必要的；今后吸烟也要秉承这个宗旨，不能连续多洗的。&lt;/p&gt;
&lt;p&gt;从长远来看，目前比较稳妥的限制在了两天一包，下面的目标还是调节自身，稳定在三天一包。&lt;/p&gt;
&lt;p&gt;允许短时间的波动，但是长远是一定要下降的，逐渐变为选择之一，而不是唯一选择。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符串相乘</title>
      <link>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sun, 25 Jun 2023 20:19:48 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>&lt;h2 id=&#34;字符串相乘httpsleetcodecnproblemsmultiply-strings&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/multiply-strings/&#34;&gt;字符串相乘&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
&lt;p&gt;注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: num1 = &amp;ldquo;123&amp;rdquo;, num2 = &amp;ldquo;456&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: &amp;ldquo;56088&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/solution-static/43/sol1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;不能转整数后相乘，也就只能各位相乘后相加了。&lt;/p&gt;
&lt;p&gt;如果中途转字符的话，还要遍历相加，这里直接使用数组承接，避免后续数值相加遍历。&lt;/p&gt;
&lt;p&gt;两个数的长度分别为&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;，如果相乘之后进位，结果长度为&lt;code&gt;A+B&lt;/code&gt;，否则为&lt;code&gt;A+B-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;直接使用数组，每个坑位计算数值，顺便相加，后续统一计算进位。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;multiply&lt;/span&gt;(num1: String, num2: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a, b) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (num1.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;(), num2.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a_len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; (b_len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; b[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 对应相乘
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ai &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;a_len).rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; av &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[ai].to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; bi &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;b_len).rev() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; bv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b[bi].to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
                arr[ai &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; bi &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; av &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; bv;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 逐步进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len)).rev() {
            arr[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; arr[i] &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            arr[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[i] &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 进位判断
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        };
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        &lt;span style=&#34;color:#75715e&#34;&gt;// 数据收集
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; begin&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;a_len&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b_len {
            res.push_str(arr[i].to_string().as_str());
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>实施戒烟</title>
      <link>https://just-worker.github.io/blog/%E5%AE%9E%E6%96%BD%E6%88%92%E7%83%9F/</link>
      <pubDate>Wed, 21 Jun 2023 23:12:28 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AE%9E%E6%96%BD%E6%88%92%E7%83%9F/</guid>
      <description>&lt;h2 id=&#34;计划回顾&#34;&gt;计划回顾&lt;/h2&gt;
&lt;p&gt;上班：1
中午：1.5
下午：1.5
烦闷：2
下班：1
日记：1&lt;/p&gt;
&lt;h2 id=&#34;实施结果&#34;&gt;实施结果&lt;/h2&gt;
&lt;p&gt;上班和下班，时间说长不短的，基本上是直接消耗，因为要转变状态，没有什么要中途思考的。
消耗完之后也就到公司(家)了，这个时候状态要跳变，所以不会有半途不吸，也能做到到了后不吸。&lt;/p&gt;
&lt;p&gt;烦闷的时候的确是有，今天有过一次，不过克制住了，消耗 1 之后继续办事了。
这个和手头的事情的多寡相关，之前只有任务很多且特别烦闷的时候，可能会持续一段时间，消耗比较大。
现在逐渐去调节心情，调节心态，就算烦闷后吸烟，大抵是太忙了，挺过之后的一个里程碑，可以克制一下。&lt;/p&gt;
&lt;p&gt;中午和下午，的确下来了，吸了一个就赶快上楼了，呆下面的确热，而且的确是收益最小的。&lt;/p&gt;
&lt;p&gt;日记后估计还是免不了，也算一种里程碑的状态转换？&lt;/p&gt;
&lt;h2 id=&#34;战绩一览&#34;&gt;战绩一览&lt;/h2&gt;
&lt;p&gt;上班：1
中午：1
下午：1
烦闷：1
下班：1
日记：1&lt;/p&gt;
&lt;p&gt;今日消耗总数 6 ， 维持及格线之上，整体无异常，继续保持。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://just-worker.github.io/blog/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Wed, 21 Jun 2023 22:49:38 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>&lt;h2 id=&#34;接雨水httpsleetcodecnproblemstrapping-rain-water&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/trapping-rain-water/&#34;&gt;接雨水&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]&lt;/li&gt;
&lt;li&gt;输出：6&lt;/li&gt;
&lt;li&gt;解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;这道题核心的点，并非在于整体环境如何，而是在于一个柱子能接多少水。&lt;/p&gt;
&lt;p&gt;是的，考虑的所谓区域，也是在柱子之后，是在最低的边界减去柱子，就是这个柱子能接住的水。&lt;/p&gt;
&lt;p&gt;是柱子，而非区域，这就是本题的核心主旨；而怎么感知这个边界，其实反而是其次的，虽然也很重要。&lt;/p&gt;
&lt;h3 id=&#34;边界&#34;&gt;边界&lt;/h3&gt;
&lt;p&gt;所谓的边界，我们可以这样推理出来：除非当前柱子更高，否则边界都是沿用之前的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trap&lt;/span&gt;(height: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left_max, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right_max) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; len], vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; len]);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 左边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        left_max[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            left_max[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(left_max[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], height[i]);
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 右边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        right_max[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;).rev() {
            right_max[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(right_max[i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], height[i]);
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 接水
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; std::cmp::min(left_max[i], right_max[i]) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; height[i];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;深化&#34;&gt;深化&lt;/h3&gt;
&lt;p&gt;有一个条件，我们认知的还不够深刻：&lt;code&gt;积水永远只和最小的边界相关&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先关心一下，边界和柱子等高的情况下，基本上就是当前的柱子作为边界，是积不了水的。&lt;/p&gt;
&lt;p&gt;不论柱子再高，积水始终是依赖最低的那一根柱子。以最低的边界进行计算&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果另一个边后续变低，边界高度不变&lt;/li&gt;
&lt;li&gt;如果另一边升高，计算还是以为当前最低边界进行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们可以利用双指针，始终挪动最低边界进行计算即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trap&lt;/span&gt;(height: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left_max, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right_max) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 维护便捷
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            left_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(height[left], left_max);
            right_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(height[right], right_max);
            &lt;span style=&#34;color:#75715e&#34;&gt;// 移动最小一边
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; height[left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; height[right] {
                res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; left_max &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; height[left];
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; right_max &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; height[right];
                right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>缺失的第一个正数</title>
      <link>https://just-worker.github.io/blog/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</link>
      <pubDate>Wed, 21 Jun 2023 22:29:04 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;-缺失的第一个正数httpsleetcodecnproblemsfirst-missing-positive&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/first-missing-positive/&#34;&gt; 缺失的第一个正数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [7,8,9,11,12]&lt;/li&gt;
&lt;li&gt;输出：1&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;这里有一些坑，其实就是最小正自然数。我们假设一个符合规格的数组应该是什么样子的：&lt;code&gt;nums[i] == i + 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是这里数字是无序的，我们尽量把符合规则的数字挪到对应的位置，然后按照上述的规则进行检查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中途有不匹配，肯定缺少了&lt;code&gt;i + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全部匹配完成，缺少 &lt;code&gt;len + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N) 移动
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;first_missing_positive&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 循环，不是把当前的数字挪到准确的位置，而是把当前位置的的目标数据挪过来
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 正数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 不大于len
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 位置不对
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[(nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; nums[i] &lt;span style=&#34;color:#75715e&#34;&gt;// 对面位置也不对
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                nums.swap(i, t &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;);
            }
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; v {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; v;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>组合总和II</title>
      <link>https://just-worker.github.io/blog/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/</link>
      <pubDate>Wed, 21 Jun 2023 22:24:39 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/</guid>
      <description>&lt;h2 id=&#34;组合总和iihttpsleetcodecnproblemscombination-sum-ii&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/combination-sum-ii/&#34;&gt;组合总和II&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的每个数字在每个组合中只能使用 一次 。&lt;/p&gt;
&lt;p&gt;注意：解集不能包含重复的组合。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,&lt;/li&gt;
&lt;li&gt;输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;经过前一题的洗礼，这道题并不困难，关键在于&lt;code&gt;不重复&lt;/code&gt;，这个在之前的题目中也有出现过，我们只需要排序后加一些条件即可。&lt;/p&gt;
&lt;p&gt;这里排序之后，还可以进行减枝：直接进行数字统计，在指定数字的时候直接遍历出同一个数字使用多次的情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combination_sum2&lt;/span&gt;(candidates: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::sort_and_count(candidates);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        Self::dfs(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; vec![], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;counter, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, target, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(collect: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, counter: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collect.iter().sum::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
            res.push(collect.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v).collect());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 必须先判断 sum , 防止遗漏
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; counter.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 跳过当前
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        Self::dfs(collect, counter, res, target, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; counter[n];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; current.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; times &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(current.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, (target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; current.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 本次直接尝试使用多个数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;times {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;i {
                collect.push(current.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
            }
            Self::dfs(collect, counter, res, target, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;i {
                collect.pop();
            }
        }
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 计数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sort_and_count&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; candidates: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;{
        candidates.sort();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; m &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; candidates {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; res.last() {
                Some(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;(v, c)) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    res.pop();
                    res.push((m, c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
                } ,
                _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    res.push((m, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>决定戒烟</title>
      <link>https://just-worker.github.io/blog/%E5%86%B3%E5%AE%9A%E6%88%92%E7%83%9F/</link>
      <pubDate>Tue, 20 Jun 2023 23:07:29 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%86%B3%E5%AE%9A%E6%88%92%E7%83%9F/</guid>
      <description>&lt;h2 id=&#34;不知觉的咳嗽&#34;&gt;不知觉的咳嗽&lt;/h2&gt;
&lt;p&gt;最近喝水也少，喉咙痒了的确咳嗽，烟的确没多抽。&lt;/p&gt;
&lt;p&gt;不过宝贝说我晚上咳嗽了，那可是在睡觉的时候。&lt;/p&gt;
&lt;p&gt;我咳嗽了么，我不知道，也不用知道。可能是我睡着的时候咳嗽了，的确逐渐严重了。也或许，是宝贝的幻听，做梦。但不论怎么说，的确是让宝贝担心了。&lt;/p&gt;
&lt;h2 id=&#34;一年戒烟&#34;&gt;一年戒烟&lt;/h2&gt;
&lt;p&gt;刚好过十字路口，我手持着燃烧过半的烟头，许下了一年戒烟的承诺。&lt;/p&gt;
&lt;p&gt;说起戒烟这东西，如今也不知是第几次，但是没有一次是真的在戒。&lt;/p&gt;
&lt;p&gt;抽或者不抽，一直都是选择题，没有什么是必须，都是自我的选择。&lt;/p&gt;
&lt;h2 id=&#34;抽烟价值&#34;&gt;抽烟价值&lt;/h2&gt;
&lt;p&gt;如果说没有烟瘾，只是习惯，那就慢慢的来。&lt;/p&gt;
&lt;p&gt;但是回到抽烟的借口上，它真的达成了目的了么。&lt;/p&gt;
&lt;p&gt;很多时候并没有，并非能够一次戒断，但是斩杀一个行为，那就是要对这个行为彻底失去动力。&lt;/p&gt;
&lt;p&gt;关于抽烟，现在更要找借口抽烟，而且是真的，有价值的借口。如果自我审视之后，觉得可以，那么自然无不可。&lt;/p&gt;
&lt;p&gt;如果我还是直接抽，那我，估计也就这样了，不只是戒烟，我个人的价值也就是如此了。&lt;/p&gt;
&lt;h2 id=&#34;每日限量&#34;&gt;每日限量&lt;/h2&gt;
&lt;p&gt;不要想着去欺骗谁，原来的确是一天一包。现在回想起来，一天怎么会消耗这么多，也的确不可思议。&lt;/p&gt;
&lt;p&gt;整体的，不过是一个又一个无聊的时光，为了停滞，为了抽烟而抽烟，因为停止抽烟，就要跳跃到下一个时间，下一件事情。这种状态是要杜绝的。&lt;/p&gt;
&lt;p&gt;可行的数量，每天四次，每次两根，一天也就八根了。&lt;/p&gt;
&lt;p&gt;后面每天，每根都登记在案吧。&lt;/p&gt;
&lt;h2 id=&#34;军火分配&#34;&gt;军火分配&lt;/h2&gt;
&lt;p&gt;实际说出来，上班的路上、回家的路上，大概率是要来一根的，那就先剔除两根。&lt;/p&gt;
&lt;p&gt;中午和下午都是要下来透透气的，就算上是四根吧。&lt;/p&gt;
&lt;p&gt;那每天所谓烦闷的时光，就用剩余两根来安慰自己。&lt;/p&gt;
&lt;p&gt;不过中午和下午的下楼，如无必要，还是需要缩减一下；按照需要回家写完日记之后再来一个的话，那就再剩下一根。&lt;/p&gt;
&lt;p&gt;那每天军火消耗的清单应该如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上班： 1&lt;/li&gt;
&lt;li&gt;中午：1.5&lt;/li&gt;
&lt;li&gt;下午：1.5&lt;/li&gt;
&lt;li&gt;烦闷：2&lt;/li&gt;
&lt;li&gt;下班：1&lt;/li&gt;
&lt;li&gt;日记：1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中烦闷的时候，还是要想办法更好的控制情绪，找回自己的坚定。逐渐用其他有意义的事情去填充时间，逐渐的，就会慢慢忘记。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://just-worker.github.io/blog/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Tue, 20 Jun 2023 22:57:50 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;组合总和httpsleetcodecnproblemscombination-sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/combination-sum/&#34;&gt;组合总和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。&lt;/p&gt;
&lt;p&gt;candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 &lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 target 的不同组合数少于 150 个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：candidates = [2,3,6,7], target = 7&lt;/li&gt;
&lt;li&gt;输出：[[2,2,3],[7]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;回溯模拟&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combination_sum&lt;/span&gt;(candidates: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        Self::search(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; vec![], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;candidates, target, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, candidates: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;  n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; candidates.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.iter().sum::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
            res.push(arr.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v).collect());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
               &lt;span style=&#34;color:#75715e&#34;&gt;// 可以利用当前数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        arr.push(candidates[n]);
        Self::search(arr, res, candidates, target, n);
        arr.pop();
        &lt;span style=&#34;color:#75715e&#34;&gt;// 可以跳过当前数据进行搜索
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        Self::search(arr, res, candidates, target, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>外观数列</title>
      <link>https://just-worker.github.io/blog/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 20 Jun 2023 22:37:52 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</guid>
      <description>&lt;h2 id=&#34;外观数列httpsleetcodecnproblemscount-and-say&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/count-and-say/&#34;&gt;外观数列&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个正整数 n ，输出外观数列的第 n 项。&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;
&lt;p&gt;你可以将其视作是由递归公式定义的数字字符串序列：&lt;/p&gt;
&lt;p&gt;countAndSay(1) = &amp;ldquo;1&amp;rdquo;
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
前五项如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;11
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;21
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1211
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;111221
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;第一项是数字 1&lt;/li&gt;
&lt;li&gt;描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &amp;ldquo;11&amp;rdquo;&lt;/li&gt;
&lt;li&gt;描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &amp;ldquo;21&amp;rdquo;&lt;/li&gt;
&lt;li&gt;描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &amp;ldquo;1211&amp;rdquo;&lt;/li&gt;
&lt;li&gt;描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &amp;ldquo;111221&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N x L)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(L)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count_and_say&lt;/span&gt;(n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; holder: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; Self::count_and_say(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;).chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; holder {
                Some(c) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    res.push_str(count.to_string().as_str());
                    res.push_str(c.to_string().as_str());
                    holder.insert(ch);
                    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                },
                _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    holder.insert(ch);
                    count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            }
        }
        res.push_str(count.to_string().as_str());
        res.push_str(holder.unwrap().to_string().as_str());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>解数独</title>
      <link>https://just-worker.github.io/blog/%E8%A7%A3%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Mon, 19 Jun 2023 23:05:48 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E8%A7%A3%E6%95%B0%E7%8B%AC/</guid>
      <description>&lt;h2 id=&#34;解数独httpsleetcodecnproblemssudoku-solver&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/sudoku-solver/&#34;&gt;解数独&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 遵循如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &amp;lsquo;.&amp;rsquo; 表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;深度遍历，一行一行尝试，如果对，那就继续尝试，到达下一行即是没有冲突，求得答案；如果中途冲突了，回溯到上一步，尝试下一个数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solve_sudoku&lt;/span&gt;(board: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; column &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; space &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; r &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;board.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;board[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[r][c];
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; {
                    space.push((r, c));
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                    column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                    area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                }
            }
        }
        Self::resolve(
            board,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; row,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; column,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; area,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;space,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; None,
            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
        );
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(
        board: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
        row: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
        column: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
        area: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;,
        space: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
        finished: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
        n: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
    ) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// 全部已经完成
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; space.len() {
            finished.insert(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 当前需要完成的空格
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (r, c) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; space[n];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; finished.is_none() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 尝试填入数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                board[r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ch;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 标记此数字已经使用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 尝试下一个空位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                Self::resolve(board, row, column, area, space, finished, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; finished.is_some() {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 恢复现场
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                board[r][c] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;;
                row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>有效的数独</title>
      <link>https://just-worker.github.io/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Mon, 19 Jun 2023 22:49:20 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</guid>
      <description>&lt;h2 id=&#34;有效的数独httpsleetcodecnproblemsvalid-sudoku&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/valid-sudoku/&#34;&gt;有效的数独&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;/li&gt;
&lt;li&gt;空白格用 &amp;lsquo;.&amp;rsquo; 表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;题意已经很清楚了，直接实现即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_valid_sudoku&lt;/span&gt;(board: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; column &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;];&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; r &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;board.len()  {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;board[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[r][c];
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                }
                row[r][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                column[c][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                area[r &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][c &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][v] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>https://just-worker.github.io/blog/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 19 Jun 2023 22:34:19 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>&lt;h2 id=&#34;搜索插入位置httpsleetcodecnproblemssearch-insert-position&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/search-insert-position/&#34;&gt;搜索插入位置&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 O(log n) 的算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: nums = [1,3,5,6], target = 5&lt;/li&gt;
&lt;li&gt;输出: 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;看到&lt;code&gt;O(log N)&lt;/code&gt;，还是二分。在我们不动&lt;code&gt;mid&lt;/code&gt;的情况下，&lt;code&gt;left=mid&lt;/code&gt;用作退出，那么，如果能找到&lt;code&gt;target&lt;/code&gt;一定已经返回，此时&lt;code&gt;nums[left] &amp;lt; target&lt;/code&gt;，插入的位置即是&lt;code&gt;left + 1&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search_insert&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mid &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; mid {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://just-worker.github.io/blog/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sun, 18 Jun 2023 23:12:21 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid>
      <description>&lt;h2 id=&#34;在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/&#34;&gt;在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;如果数组中不存在目标值 target，返回 [-1, -1]。&lt;/p&gt;
&lt;p&gt;你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [5,7,7,8,8,10], target = 8&lt;/li&gt;
&lt;li&gt;输出：[3,4]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;看时间复杂度，还是二分；这里主要分析一下什么情况下靠左，什么情况下靠右。&lt;/p&gt;
&lt;p&gt;遇见二分的时候，会遇见这样的模板代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target {
    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;仔细观察一下，比较符号采用的是&lt;code&gt;&amp;lt;&lt;/code&gt;，这种情况下，对于&lt;code&gt;left&lt;/code&gt;而言，是不会错过&lt;code&gt;target&lt;/code&gt;的，不断缩减的是&lt;code&gt;right&lt;/code&gt;，当到达临界的时候，&lt;code&gt;left&lt;/code&gt;就到达了&lt;code&gt;target&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;如果是小于等于的情况呢&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; target {
    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以发现就算等于了&lt;code&gt;target&lt;/code&gt;也会溜走，继续向右移动；不过此时得到的位置会向后偏移一位。&lt;/p&gt;
&lt;p&gt;不过由于外层的&lt;code&gt;left &amp;lt; right&lt;/code&gt;的循环，对于一些特殊的场景，无法做到万金油。换一种思路，我们只要搜索到&lt;code&gt;left + 1 &amp;gt;= right&lt;/code&gt;的地步，其实就能够直接拿到当前的结果，只是需要在具体搜索的地方进行额外的判断即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search_range&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; nums[len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::search(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums, target, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![
            left,
            Self::search(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums, target, left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)
        ]

    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search&lt;/span&gt;(nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, close_right: &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left, right);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// left == right || left + 1 == right
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; mid {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// mid 不进行偏移，尽可能的保证 target
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; close_right {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; target {
                    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target {
                    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
                }
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 靠近左侧
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;close_right {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 优先取左侧
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 次一点取右侧
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[right] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[right] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target { &lt;span style=&#34;color:#75715e&#34;&gt;// 优先右侧
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {  &lt;span style=&#34;color:#75715e&#34;&gt;// 次一点左侧
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        } 
        &lt;span style=&#34;color:#75715e&#34;&gt;// 都不匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;一个陷进&#34;&gt;一个陷进&lt;/h2&gt;
&lt;p&gt;有一个坑点，那就是既然知道了&lt;code&gt;left&lt;/code&gt;，顺序查找&lt;code&gt;right&lt;/code&gt;是否能够加速；因为如果都是同数字的数组，遍历一遍就是&lt;code&gt;O(N)&lt;/code&gt;了，这样并不能达成结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>搜索旋转排序数组</title>
      <link>https://just-worker.github.io/blog/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 18 Jun 2023 22:50:55 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;h2 id=&#34;搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-array&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/search-in-rotated-sorted-array/&#34;&gt;搜索旋转排序数组&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;整数数组 nums 按升序排列，数组中的值 互不相同 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。&lt;/p&gt;
&lt;p&gt;给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。&lt;/p&gt;
&lt;p&gt;你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [4,5,6,7,0,1,2], target = 0&lt;/li&gt;
&lt;li&gt;输出：4&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;从题目中要求的 &lt;code&gt;O(log n)&lt;/code&gt; 时间复杂度，很明显就想到是二分了；对于一个旋转数组，二分之后必定有一半是有序，利用这一半反推另一半即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[right] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; mid {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mid &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 左侧有序
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[mid] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[mid] {
                    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[mid] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[right] {
                    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            }
            
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>最长有效括号</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sat, 17 Jun 2023 23:18:55 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>&lt;h2 id=&#34;最长有效括号httpsleetcodecnproblemslongest-valid-parentheses&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-valid-parentheses/&#34;&gt;最长有效括号&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;(()&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：2&lt;/li&gt;
&lt;li&gt;解释：最长有效括号子串是 &amp;ldquo;()&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;本题关键在于连通性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;code&gt;()((()))&lt;/code&gt;怎么判断联通性，直接计算即可&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;()))&lt;/code&gt;，右侧匹配过多，打断即可&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;()((()&lt;/code&gt;如何判断联通性，因为不能提前打断匹配，无法判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们只能有两种办法来测试这种联通性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用栈匹配+临时变量，在打断匹配和字符结束的时候，结合匹配和残余的栈数据强行计算&lt;/li&gt;
&lt;li&gt;连通性正反对称，且如果存在打断，正向无法提前判断的逆向可以提前判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，我们选择正反遍历，单纯的只关心左右括号相等以及打断的情况，结合正反两个结果取最高。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_valid_parentheses&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars:Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars.len() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; chars.iter() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ch {
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; left {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; right {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(res, left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right);
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; chars.iter().rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ch {
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; right {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(res, left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right);
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>下一个排列</title>
      <link>https://just-worker.github.io/blog/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 17 Jun 2023 23:01:05 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
      <description>&lt;h2 id=&#34;下一个排列httpsleetcodecnproblemsnext-permutation&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/next-permutation/&#34;&gt;下一个排列&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。&lt;/li&gt;
&lt;li&gt;类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。&lt;/li&gt;
&lt;li&gt;而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个整数数组 nums ，找出 nums 的下一个排列。&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;首先，考虑一个极端情况：已经是最大自然序怎么办。当然是回归到最小自然序，考虑到当前就是最大自然序，通过双指针交换可以很便捷的完成这一操作。&lt;/p&gt;
&lt;p&gt;第二个问题，怎么计算下一个自然序呢。好像回到了题目本身，不过真实的思考是：怎么样才能让当前的序列更大一些。
这样就很好办了，可以把一个序列更大的数值向前移动，这样就能够让整体序列更大了。
因为要下一个自然序，我们必然从尾部开始查找，找到第一个&lt;code&gt;nums[i] &amp;gt; nums[i-1]&lt;/code&gt;，这就是我们要操作的边界。&lt;/p&gt;
&lt;p&gt;要让&lt;code&gt;nums[i-1]&lt;/code&gt;变得更大的前提是，不能动&lt;code&gt;0~i&lt;/code&gt;之间的数，我们必须在&lt;code&gt;[i..]&lt;/code&gt;之间找到一个比&lt;code&gt;nums[i-1]&lt;/code&gt;更大一些的数值来替换它。&lt;/p&gt;
&lt;p&gt;最后一个问题：因为&lt;code&gt;nums[i-1]&lt;/code&gt;发生了进位，剩下的数值需要回归最小自然序，怎么办呢。&lt;/p&gt;
&lt;p&gt;根据&lt;code&gt;i&lt;/code&gt;的查找定义，&lt;code&gt;nums[i..]&lt;/code&gt;肯定是一个降序排列，我们只需要采用最开始的办法进行操作即可。&lt;/p&gt;
&lt;p&gt;同时，查找到&lt;code&gt;i=0&lt;/code&gt;的情况，本身也是一样的操作，两者合并，题解完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next_permutation&lt;/span&gt;(nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len).rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[i] {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; swap &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len).rev() {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[swap] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; nums[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                        nums.swap(swap, i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                    }
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            nums.swap(left, right);
            left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>串联所有单词的子串</title>
      <link>https://just-worker.github.io/blog/%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sat, 17 Jun 2023 22:33:55 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;串联所有单词的子串httpsleetcodecnproblemssubstring-with-concatenation-of-all-words&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/substring-with-concatenation-of-all-words/&#34;&gt;串联所有单词的子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。&lt;/p&gt;
&lt;p&gt; s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，如果 words = [&amp;ldquo;ab&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ef&amp;rdquo;]， 那么 &amp;ldquo;abcdef&amp;rdquo;， &amp;ldquo;abefcd&amp;rdquo;，&amp;ldquo;cdabef&amp;rdquo;， &amp;ldquo;cdefab&amp;rdquo;，&amp;ldquo;efabcd&amp;rdquo;， 和 &amp;ldquo;efcdab&amp;rdquo; 都是串联子串。 &amp;ldquo;acdbef&amp;rdquo; 不是串联子串，因为他不是任何 words 排列的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;barfoothefoobarman&amp;rdquo;, words = [&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;输出：[0,9]&lt;/li&gt;
&lt;li&gt;解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 &amp;ldquo;barfoo&amp;rdquo; 开始位置是 0。它是 words 中以 [&amp;ldquo;bar&amp;rdquo;,&amp;ldquo;foo&amp;rdquo;] 顺序排列的连接。
子串 &amp;ldquo;foobar&amp;rdquo; 开始位置是 9。它是 words 中以 [&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;问题一：如何判断一个字符串的&lt;code&gt;字符异位词&lt;/code&gt;。答案不言而喻：词频统计。&lt;/p&gt;
&lt;p&gt;问题二：一个长字符串，如何统计&lt;code&gt;字符异位词&lt;/code&gt;个数。答案：滚动词频统计。&lt;/p&gt;
&lt;p&gt;问题三：长字符串有多少种分割方式。答案：&lt;code&gt;word_length&lt;/code&gt;种，因为确定了首位，后续的直接滚动即可。&lt;/p&gt;
&lt;p&gt;这样就能解答本道题了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time : O(WORD_LENGTH * STRING_LENGTH)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(WORD_LENGTH * WORD_COUNT)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_substring&lt;/span&gt;(s: String, words: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (word_count, word_length) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (words.len(), words[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (combine_length, string_length) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (word_count &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; word_length, s.len());
        &lt;span style=&#34;color:#75715e&#34;&gt;// 长度不够，直接淘汰
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; combine_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 多种分割，依靠字符长度判断，后续都会周期重复
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; offset &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;word_length {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 词频统计
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;::new();
            &lt;span style=&#34;color:#75715e&#34;&gt;// 基础词频
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; word &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; words.iter() {
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;counter.entry(word).or_insert(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 滚动词频统计
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; begin &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (offset&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; word_length &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;).step_by(word_length) {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 滚动录入的单词
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;s[begin&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; word_length];
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;counter.entry(current).or_insert(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; counter[current] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    counter.remove(current);
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 滚动退出的单词
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; combine_length {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;s[begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; combine_length&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; combine_length &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; word_length];
                    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;counter.entry(last).or_insert(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; counter[last] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                        counter.remove(last);
                    }
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 词频消弭，匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; counter.is_empty() {
                    res.push((begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; combine_length &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; word_length) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;);
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;滑动边界需要小心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数相除</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</link>
      <pubDate>Fri, 16 Jun 2023 22:36:23 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</guid>
      <description>&lt;h2 id=&#34;两数相除httpsleetcodecnproblemsdivide-two-integers&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/divide-two-integers/&#34;&gt;两数相除&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。&lt;/p&gt;
&lt;p&gt;整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。&lt;/p&gt;
&lt;p&gt;返回被除数 dividend 除以除数 divisor 得到的 商 。&lt;/p&gt;
&lt;p&gt;注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: dividend = 10, divisor = 3&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;li&gt;解释: 10/3 = 3.33333.. ，向零截断后得到 3 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;两个技巧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移位作为乘2&lt;/li&gt;
&lt;li&gt;进制作为基础&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微软面试题：把水果放篮子里，放好之后说出任意数字，只准提篮子组成任意数字。答案：按照二进制放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解这道题已经足够了，在修饰一下边界情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被除数等于零&lt;/li&gt;
&lt;li&gt;除数等于正负1&lt;/li&gt;
&lt;li&gt;负数转正数会溢出，一律转为负数进行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(logC)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;(dividend: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, divisor: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; divisor &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dividend;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; divisor &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;dividend;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; rev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            rev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;dividend
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            dividend
        };
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; divisor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; divisor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            rev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;rev;
            &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;divisor
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            divisor
        };

        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; candidate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![divisor];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; candidate[last] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; candidate[last] {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; double &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; candidate[last] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; candidate[last];
            candidate.push(double);
            last &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;last).rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dividend &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; candidate[i] {
                dividend &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; candidate[i];
                res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i);
            } 
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; rev {
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;res;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>找出字符串中第一个匹配项的下标2</title>
      <link>https://just-worker.github.io/blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%872/</link>
      <pubDate>Thu, 15 Jun 2023 22:37:40 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%872/</guid>
      <description>&lt;h2 id=&#34;再续前缘&#34;&gt;再续前缘&lt;/h2&gt;
&lt;p&gt;前面说过&lt;a href=&#34;https://just-worker.github.io/blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/&#34;&gt;找出字符串中第一个匹配项的下标&lt;/a&gt;和&lt;a href=&#34;https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/&#34;&gt;最长回文子串&lt;/a&gt;很像；其中一个是&lt;code&gt;KMP&lt;/code&gt;，另一个是&lt;code&gt;马拉车&lt;/code&gt;。两者都是字符串匹配，而且核心观念是&lt;code&gt;如何传导已经计算过的结果&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;马拉车&lt;/code&gt;是利用了对称的特性，那么&lt;code&gt;KMP&lt;/code&gt;怎么复用信息呢，我们自己推理一波。&lt;/p&gt;
&lt;h2 id=&#34;计算复用&#34;&gt;计算复用&lt;/h2&gt;
&lt;p&gt;原来计算过程中，我们每次都需要匹配，这是必不可少的。那么，有什么信息是可以复用的呢。&lt;/p&gt;
&lt;p&gt;我们比对失败之后，都会向后移动一位，这样对么？反过来，我们在哪一位比对失败的呢，之前比对过的信息能够发挥一些余热呢。&lt;/p&gt;
&lt;p&gt;当然，这个特征肯定只和&lt;code&gt;pattern&lt;/code&gt;字符息息相关，我们深入挖掘一下。&lt;/p&gt;
&lt;h2 id=&#34;字符前缀&#34;&gt;字符前缀&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果当前位置匹配失败，什么情况下可以复用已经比对过的信息?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们之前始终是向前移动一位，肯定不会错，但是的确漏掉了什么。假设我们比对过程中，记住原字符串中和首字符串相等的位置，每次移动是否会更加便捷呢，答案是肯定的。这样我们肯定是会比原来的效率高一些的，但是极端情况下，并没有任何改善。因为如果同首字符串相等的位置太多，避免不了重复计算。&lt;/p&gt;
&lt;p&gt;从这里吸取教训，我们每次移动的位置，应该是尽可能匹配的最长的前缀的进行移动。单纯的依靠首字符是不够的。然而，比较的字符串是不可靠的，是未知的，我们只能从&lt;code&gt;pattern&lt;/code&gt;字符串着手。&lt;/p&gt;
&lt;p&gt;现在，我们模糊的知道三个关键要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量按照最大匹配前缀进行移动&lt;/li&gt;
&lt;li&gt;匹配失败字符之前必定存在匹配字符(首字符匹配失败当空字符匹配)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找出不依靠外物的前缀匹配字符的关系，自然而然就落在了匹配失败的字符之前的必定匹配好的字符上面了。&lt;/p&gt;
&lt;h2 id=&#34;前缀相等&#34;&gt;前缀相等&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;abcabcabe&lt;/code&gt;和&lt;code&gt;abcabe&lt;/code&gt;怎么进行匹配呢，首次匹配必定在&lt;code&gt;c&lt;/code&gt;对&lt;code&gt;e&lt;/code&gt;的地方匹配失败，那对于&lt;code&gt;abcabc&lt;/code&gt;和&lt;code&gt;abcabe&lt;/code&gt;怎么进行移动最好呢。&lt;/p&gt;
&lt;p&gt;很明显，可定是直接跳过前面三个，第二个&lt;code&gt;abc&lt;/code&gt;进行对齐匹配，然后直接得出答案。&lt;/p&gt;
&lt;p&gt;是的，这就是我们需要的关键因素了：通过在已经匹配的字符中，直接跳到前缀匹配的下一个位置，然后开始新的一轮比较。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这样保证了每次检查都是有效检查，避免了重复检测，时间复杂度来到了线性的&lt;code&gt;O(N)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;对称计算&#34;&gt;对称计算&lt;/h2&gt;
&lt;p&gt;怎么计算这个前缀的对称性呢，回到我们的例子:&lt;code&gt;abcabcabe&lt;/code&gt;和&lt;code&gt;abcabe&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不难发现两个点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串始终只能够从首字符串进行匹配&lt;/li&gt;
&lt;li&gt;后续字符串依赖前一个字符串的匹配结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，把每个位置匹配失败后移动的位数总集表示为一个数组&lt;code&gt;arr[N]&lt;/code&gt;，每个位置匹配失败需要移动的位数就确定了。现在按照前面两个主旨下降成具体操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前字符作为某个字符起始的前缀，和真实前缀进行匹配，匹配成功则当前位移+1，匹配失败则向前查找相似前缀&lt;/li&gt;
&lt;li&gt;最初前缀即真实前缀，即查找字符的首字母，如果没有相似前缀，只能把当前字符进行前缀进行比较&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(chars: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars.len();
        &lt;span style=&#34;color:#75715e&#34;&gt;// 首位肯定不和自己匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; len];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 前缀长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 非首位匹配，查找相似前缀
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chars[current] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[cursor] {
                cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next[cursor &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 首位匹配: 前缀+1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 前缀匹配: 前缀+1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars[current] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chars[cursor] {
                cursor &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 更新当前的前缀值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            next[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cursor;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; next;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，对于在&lt;code&gt;i&lt;/code&gt;位置的字符串匹配失败，我们通过查表就可以知道下一位应该从哪里继续匹配。如果没有匹配前缀，那下一位只能从查找字符的首字符进行匹配。&lt;/p&gt;
&lt;p&gt;结合例子：&lt;code&gt;abcabcabe&lt;/code&gt;和&lt;code&gt;abcabe&lt;/code&gt;。计算出的&lt;code&gt;next=[0,0,0,1,2,0]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首次匹配失败之后，对于&lt;code&gt;(c)ab&lt;/code&gt;，我们就不会从头进行匹配，这对下一个位置，我们会从第二个位置开始匹配，也就是&lt;code&gt;(ab)c&lt;/code&gt;进行匹配。&lt;/p&gt;
&lt;h2 id=&#34;kmp&#34;&gt;KMP&lt;/h2&gt;
&lt;p&gt;重新解读了一下，这就是&lt;code&gt;KMP&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M + N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;str_str&lt;/span&gt;(haystack: String, needle: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; origin: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; haystack.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pattern: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; needle.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (origin_len, pattern_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (origin.len(), pattern.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; pattern_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; origin_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::next(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pattern);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; origin_idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;origin_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; pattern[pattern_idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; origin[origin_idx] {
                pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next[pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; pattern[pattern_idx] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; origin[origin_idx] {
                pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; pattern_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pattern_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (origin_idx &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pattern_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(chars: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars.len();
        &lt;span style=&#34;color:#75715e&#34;&gt;// 首位肯定不和自己匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; len];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 前缀长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 非首位匹配，查找相似前缀
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chars[current] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[cursor] {
                cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next[cursor &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 首位匹配: 前缀+1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 前缀匹配: 前缀+1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars[current] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chars[cursor] {
                cursor &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 更新当前的前缀值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            next[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cursor;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>找出字符串中第一个匹配项的下标</title>
      <link>https://just-worker.github.io/blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</link>
      <pubDate>Wed, 14 Jun 2023 23:46:55 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</guid>
      <description>&lt;h2 id=&#34;找出字符串中第一个匹配项的下标httpsleetcodecnproblemsfind-the-index-of-the-first-occurrence-in-a-string&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/&#34;&gt;找出字符串中第一个匹配项的下标&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：0&lt;/li&gt;
&lt;li&gt;解释：&amp;ldquo;sad&amp;rdquo; 在下标 0 和 6 处匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;逐个匹配&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M * N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;str_str&lt;/span&gt;(haystack: String, needle: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; origin: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; haystack.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pattern: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; needle.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (origin_len, pattern_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (origin.len(), pattern.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; pattern_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; origin_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;outer&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;for&lt;/span&gt; origin_idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(origin_len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pattern_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; pattern_idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;pattern_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; origin[origin_idx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; pattern_idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; pattern[pattern_idx] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt; &amp;#39;outer;
                }
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; origin_idx &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;下回继续&#34;&gt;下回继续&lt;/h2&gt;
&lt;p&gt;和之前的&lt;a href=&#34;https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/&#34;&gt;马拉车&lt;/a&gt;一样，有没有什么信息能够继续传递的呢。下一章继续。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移除元素</title>
      <link>https://just-worker.github.io/blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 14 Jun 2023 23:39:32 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;h2 id=&#34;移除元素httpsleetcodecnproblemsremove-element&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/remove-element/&#34;&gt;移除元素&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-输入：nums = [3,2,2,3], val = 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出：2, nums = [2,2]&lt;/li&gt;
&lt;li&gt;解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;双指针&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_element&lt;/span&gt;(nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, val: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[right] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; val {
                nums[(left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[right];
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>删除有序数组中的重复项</title>
      <link>https://just-worker.github.io/blog/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Wed, 14 Jun 2023 23:19:38 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;删除有序数组中的重复项httpsleetcodecnproblemsremove-duplicates-from-sorted-array&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/remove-duplicates-from-sorted-array/&#34;&gt;删除有序数组中的重复项&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。&lt;/p&gt;
&lt;p&gt;考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 k 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [1,1,2]&lt;/li&gt;
&lt;li&gt;输出：2, nums = [1,2,_]&lt;/li&gt;
&lt;li&gt;解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;升序列表，检索到的数据一定大于之前的数据。采用双指针，只要右指针的数据大于左指针数据，复制数据，更新坐标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_duplicates&lt;/span&gt;(nums: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[right] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; nums[left] {
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                nums[left] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[right];
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>K个一组翻转链表</title>
      <link>https://just-worker.github.io/blog/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 14 Jun 2023 22:51:21 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;k个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/reverse-nodes-in-k-group/&#34;&gt;K个一组翻转链表&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：head = [1,2,3,4,5], k = 2&lt;/li&gt;
&lt;li&gt;输出：[2,1,4,3,5]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;没办法，硬算&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverse_k_group&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, k: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;outer&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;while&lt;/span&gt; head.is_some() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;k {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cursor.is_none() {
                    tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head.take();
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; &amp;#39;outer;
                }
                cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor.as_mut().unwrap().next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; reverse;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;k {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; remain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head.as_mut().unwrap().next.take();
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; added &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cursor.as_mut().unwrap().next.take();
                head.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; added;
                cursor.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
                head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remain; 
            }
            println!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{:?}-{:?}&amp;#34;&lt;/span&gt;, tail, reverse);
            tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reverse.unwrap().next;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; tail.as_mut().unwrap().next.is_some() {
                tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>两两交换链表中的节点</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 14 Jun 2023 22:39:11 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>&lt;h2 id=&#34;两两交换链表中的节点httpsleetcodecnproblemsswap-nodes-in-pairs&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/swap-nodes-in-pairs/&#34;&gt;两两交换链表中的节点&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：head = [1,2,3,4]&lt;/li&gt;
&lt;li&gt;输出：[2,1,4,3]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;重新拼接即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;swap_pairs&lt;/span&gt;(head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; head.is_none() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; head;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode{val: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, next: &lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;}));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tail.as_mut().unwrap().next.take();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next.is_none() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; next_next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next.as_mut().unwrap().next.take();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_next.is_none() {
                tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; others &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_next.as_mut().unwrap().next.take();
            next.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; others;
            next_next.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next;
            tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_next;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
                tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>合并K个升序链表</title>
      <link>https://just-worker.github.io/blog/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 12 Jun 2023 23:41:11 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;合并k个升序链表httpsleetcodecnproblemsmerge-k-sorted-lists&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/merge-k-sorted-lists/&#34;&gt;合并K个升序链表&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
将它们合并到一个有序链表中得到。
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;这里存在两种分形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个链表合并一个数组链表&lt;/li&gt;
&lt;li&gt;数组链表合并&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过其中的基石都是两个数组合并，可以复用之前的&lt;a href=&#34;&#34;&gt;合并两个有序链表&lt;/a&gt;，这里主要实现第二种方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(kn x logk)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(logk) // 递归深度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge_k_lists&lt;/span&gt;(lists: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lists.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; None;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].clone();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::merge_two_lists(lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].clone(), lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].clone());
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (vec![], vec![]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i, l) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; lists.into_iter().enumerate() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; mid {
                left.push(l);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right.push(l);
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::merge_two_lists(
            Self::merge_k_lists(left), 
            Self::merge_k_lists(right));
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge_two_lists&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; list1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; list2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (list1, list2) {
                (Some(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a), Some(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b)) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a.val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; b.val {
                        list1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.next.take();
                        tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(a);
                        tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
                        list2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(b);
                    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                        list2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b.next.take();
                        tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(b);
                        tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
                        list1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(a);
                    }
                },
                (a, b) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.or(b);
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>括号生成</title>
      <link>https://just-worker.github.io/blog/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
      <pubDate>Mon, 12 Jun 2023 23:23:17 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
      <description>&lt;h2 id=&#34;括号生成httpsleetcodecnproblemsgenerate-parentheses&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/generate-parentheses/&#34;&gt;括号生成&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：n = 3&lt;/li&gt;
&lt;li&gt;输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;手动生成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_parenthesis&lt;/span&gt;(n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        Self::generate(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string(), n, n);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate&lt;/span&gt;(res: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, current: String, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            res.push(current);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        Self::generate(res, format!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{current}(&amp;#34;&lt;/span&gt;), left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, right);
        Self::generate(res, format!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{current})&amp;#34;&lt;/span&gt;), left, right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>合并两个有序链表</title>
      <link>https://just-worker.github.io/blog/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 12 Jun 2023 23:09:11 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/merge-two-sorted-lists/&#34;&gt;合并两个有序链表&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：l1 = [1,2,4], l2 = [1,3,4]&lt;/li&gt;
&lt;li&gt;输出：[1,1,2,3,4,4]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;原地操作会很难，但如果是链表的话，手动合并就还好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M + N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge_two_lists&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; list1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; list2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (list1, list2) {
                (Some(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a), Some(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b)) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a.val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; b.val {
                        list1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.next.take();
                        tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(a);
                        tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
                        list2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(b);
                    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                        list2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b.next.take();
                        tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(b);
                        tail &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; tail.as_mut().unwrap().next;
                        list1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(a);
                    }
                },
                (a, b) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    tail.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.or(b);
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>有效的括号</title>
      <link>https://just-worker.github.io/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 12 Jun 2023 23:07:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>&lt;h2 id=&#34;有效的括号httpsleetcodecnproblemsvalid-parentheses&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/valid-parentheses/&#34;&gt;有效的括号&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;()&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;栈的运用，不必多说&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_valid&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; chars.into_iter() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch), stack.last()) {
                (None, _) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (_, None) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    stack.push(ch);
                },
                (Some(a), Some(b)) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    stack.pop();
                },
                _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; stack.is_empty();

    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::new();
        map.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;);
        map.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;);
        map.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; map;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>删除链表的倒数第N个结点</title>
      <link>https://just-worker.github.io/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Sun, 11 Jun 2023 23:08:08 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>&lt;h2 id=&#34;删除链表的倒数第n个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&#34;&gt;删除链表的倒数第N个结点&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：head = [1,2,3,4,5], n = 2&lt;/li&gt;
&lt;li&gt;输出：[1,2,3,5]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;有点遗憾的是，由于&lt;code&gt;rust&lt;/code&gt;语法的问题，是不能够同时存在一个实体的两个可变引用的，只能想办法绕过去。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;unsafe&lt;/code&gt;之外，只能使用如下特殊办法。&lt;/p&gt;
&lt;h3 id=&#34;镜像克隆&#34;&gt;镜像克隆&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N); 其实是O(1)，语法问题，没办法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_nth_from_end&lt;/span&gt;(head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode {val: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, next: &lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;}));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy.clone();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; fast.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fast.is_some() {
            slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; slow.as_mut().unwrap().next;
            fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; fast.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; slow.as_mut().unwrap().next.take();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; target.is_some() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; target.as_ref().unwrap().next.is_some() {
            slow.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target.as_mut().unwrap().next.take();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;长度探查&#34;&gt;长度探查&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_nth_from_end&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; depth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; cursor.is_some() {
            cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor.as_mut().unwrap().next;
            depth &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode{val: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, next: &lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;}));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dummy;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(depth &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; n) {
            cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; cursor.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cursor.as_mut().unwrap().next.take();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; target.is_some() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; target.as_mut().unwrap().next.is_some() {
            cursor.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target.as_mut().unwrap().next.take();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dummy.unwrap().next;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;递归&#34;&gt;递归&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove_nth_from_end&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::recursive_remove_reverse_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head, n) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; head.unwrap().next;
        }
        head
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;recursive_remove_reverse_nth&lt;/span&gt;(head: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, n: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; head.is_none() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; head.as_mut().unwrap().next;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next.is_none() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::recursive_remove_reverse_nth(next, n);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; prev &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n {
            head.as_mut().unwrap().next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head.as_mut().unwrap().next.take().unwrap().next.take();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; prev &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;rust必知必会&#34;&gt;&lt;code&gt;rust&lt;/code&gt;必知必会&lt;/h2&gt;
&lt;p&gt;拆分作用域，隔离两个可变引用(变量)，防止交叉修改导致语法不过。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>四数之和</title>
      <link>https://just-worker.github.io/blog/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 10 Jun 2023 17:19:29 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;四数之和httpsleetcodecnproblems4sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/4sum/&#34;&gt;四数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= a, b, c, d &amp;lt; n&lt;/li&gt;
&lt;li&gt;a、b、c 和 d 互不相同&lt;/li&gt;
&lt;li&gt;nums[a] + nums[b] + nums[c] + nums[d] == target&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以按 任意顺序 返回答案 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [1,0,-1,0,-2,2], target = 0&lt;/li&gt;
&lt;li&gt;输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;这道题和之前的&lt;a href=&#34;https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/&#34;&gt;两数之和&lt;/a&gt;和&lt;a href=&#34;&#34;&gt;三数之和&lt;/a&gt;完全不能比。简直就是垃圾，废弃物，装逼题。&lt;/p&gt;
&lt;p&gt;仅仅是新增了一个溢出的坑，没有任何新的技巧，纯粹就是恶心人的题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N^3)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(logN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;four_sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![];
        }
        nums.sort();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; first &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; first &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[first] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[first &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; second &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; second &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[second] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[second &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (nums[first] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[second]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; fourth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; third &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (second &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; third &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; second &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[third] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[third &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
                    }
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fourth &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; third &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (nums[third] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[fourth]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sum {
                        fourth &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; fourth &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; third {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                    }
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (nums[third] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[fourth]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; sum {
                        res.push(vec![nums[first], nums[second], nums[third], nums[fourth]]);
                    }
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>电话号码的字母组合</title>
      <link>https://just-worker.github.io/blog/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Sat, 10 Jun 2023 16:55:04 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>&lt;h2 id=&#34;电话号码的字母组合httpsleetcodecnproblemsletter-combinations-of-a-phone-number&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/letter-combinations-of-a-phone-number/&#34;&gt;电话号码的字母组合&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：digits = &amp;ldquo;23&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：[&amp;ldquo;ad&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;af&amp;rdquo;,&amp;ldquo;bd&amp;rdquo;,&amp;ldquo;be&amp;rdquo;,&amp;ldquo;bf&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ce&amp;rdquo;,&amp;ldquo;cf&amp;rdquo;]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;挑选字符组合，这里直接生成就好了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(3^m + 4^n)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: (m + n)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;letter_combinations&lt;/span&gt;(digits: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; digits.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars.len() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string()];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; chars.iter() {
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::generate(res, map.get(ch));
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate&lt;/span&gt;(prefix: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, chs: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chs.is_none() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; prefix;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; p &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; prefix.iter() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; chs.unwrap() {
                res.push(format!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{p}{ch}&amp;#34;&lt;/span&gt;));
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::new();
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;f&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;i&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;j&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;l&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;o&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;q&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;u&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;v&amp;#39;&lt;/span&gt;]);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;w&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;z&amp;#39;&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>最接近的三数之和</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 10 Jun 2023 16:34:20 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;最接近的三数之和httpsleetcodecnproblems3sum-closest&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/3sum-closest/&#34;&gt;最接近的三数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。&lt;/p&gt;
&lt;p&gt;返回这三个数的和。&lt;/p&gt;
&lt;p&gt;假定每组输入只存在恰好一个解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [-1,2,1,-4], target = 1&lt;/li&gt;
&lt;li&gt;输出：2&lt;/li&gt;
&lt;li&gt;解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;和上一题&lt;a href=&#34;&#34;&gt;三数之和&lt;/a&gt;相比，本次题解就是其中的子集，毫无疑问。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;three_sum_closest&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        nums.sort();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; first &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; first &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[first] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[first &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; second, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; third) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; third &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; second {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[first] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[second] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[third];
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; target;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target {
                    third &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    second &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; current_delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum).abs();
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current_delta &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; delta {
                    delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current_delta;
                    res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum;
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里还有一个方法，按照三数之和的办法对&lt;code&gt;second&lt;/code&gt;进行去重，可以优化一下，避免重复计算；记得边界限定哦，没有重复数据的要求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>三数之和</title>
      <link>https://just-worker.github.io/blog/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 10 Jun 2023 16:23:24 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;三数之和httpsleetcodecnproblems3sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/3sum/&#34;&gt;三数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请&lt;/p&gt;
&lt;p&gt;你返回所有和为 0 且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [-1,0,1,2,-1,-4]&lt;/li&gt;
&lt;li&gt;输出：[[-1,-1,2],[-1,0,1]]&lt;/li&gt;
&lt;li&gt;解释：&lt;/li&gt;
&lt;li&gt;nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。&lt;/li&gt;
&lt;li&gt;nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。&lt;/li&gt;
&lt;li&gt;nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。&lt;/li&gt;
&lt;li&gt;不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。&lt;/li&gt;
&lt;li&gt;注意，输出的顺序和三元组的顺序并不重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;和之前的&lt;a href=&#34;https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/&#34;&gt;两数之和&lt;/a&gt;类似，所谓的三个数之和的不可重复，经过排序之后就可以很好的解决。从简单的手段来看，直接计算需要&lt;code&gt;O(N ^ 3)&lt;/code&gt;的复杂度，排序的复杂度也就&lt;code&gt;O(NlogN)&lt;/code&gt;，这是可以接受的。核心问题在于，能否降低最高的时间复杂度。&lt;/p&gt;
&lt;p&gt;相对于原来两数之和使用额外空间来存储关系，最后达成&lt;code&gt;O(N)&lt;/code&gt;的时间复杂度来说，如果数组存在有序，使用双指针，两个数之和是可以达到&lt;code&gt;O(N)&lt;/code&gt;的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N ^ 2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;three_sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        nums.sort();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; nums[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; nums[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[k] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sum {
                    k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; j {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[k] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; sum {
                    res.push(vec![nums[i], nums[j], nums[k]]);
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Thu, 08 Jun 2023 22:37:46 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>&lt;h2 id=&#34;最长公共前缀httpsleetcodecnproblemslongest-common-prefix&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-common-prefix/&#34;&gt;最长公共前缀&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：strs = [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;fl&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;h3 id=&#34;横切与纵切&#34;&gt;横切与纵切&lt;/h3&gt;
&lt;p&gt;判断最长的公共前缀，基础的办法可以分为横切和纵切&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;横切：每个字符串按照前缀匹配，字符串依次传递&lt;/li&gt;
&lt;li&gt;纵切：设定前缀，多个字符串直接匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通俗一点来说，其实就是先遍历字符还是先遍历前缀长度的区别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_common_prefix&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; strs.len() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; strs.len() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].to_owned();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::column_slice(strs.into_iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; s.chars().collect()).collect());
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;row_slice&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][idx];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; strs.iter() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; target {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s.iter().enumerate().filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; idx).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;v).collect();
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].iter().collect();
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;column_slice&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; holder: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; strs.into_iter() {
            holder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(&lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; holder {
                None &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    s
                },
                Some(prefix) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(prefix.len(), s.len());
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; split &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; prefix[idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; s[idx] {
                            split &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                        }
                    }
                    prefix.into_iter().enumerate().filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; split).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v).collect()
                }
            });
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; holder.unwrap().iter().collect();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;分形&#34;&gt;分形&lt;/h3&gt;
&lt;p&gt;使用递推求解，其中最关键的是状态转移方程；对于一些形式比较相近的东西，直接通过分形，转化为递推的形式进行求解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(NM)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(logN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {

   &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_common_prefix&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].clone();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a :Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].chars().collect();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b :Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;  strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].chars().collect();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(a.len(), b.len());
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; split &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a[idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; b[idx] {
                    split &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a.into_iter().enumerate().filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; split).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v).collect();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (vec![], vec![]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (idx, string) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; strs.into_iter().enumerate() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; mid {
                left.push(string);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right.push(string);
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::longest_common_prefix(
            vec![
                Self::longest_common_prefix(left),
                Self::longest_common_prefix(right)
            ]);
   } 

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本身递推也算一种分形，还有一种分形就是一个字符串和一组字符串的合并，这里就不列举了。&lt;/p&gt;
&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;p&gt;前面的分形，还是执着于结果的直接计算，但是对于区域内不确定答案，除了查找，我们还可以进行搜索。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相似的情况之前遇到过，可以查看&lt;a href=&#34;https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/&#34;&gt;寻找两个正序数组的中位数2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {

   &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_common_prefix&lt;/span&gt;(strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].clone();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; strs: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs.into_iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; s.chars().collect()).collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;strs, left) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.to_string();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;strs, right) {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; left {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;strs, mid) {
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].iter().enumerate().filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; left).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v).collect()
   }

   &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;match_pos&lt;/span&gt;(strs: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, pos: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; pos {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;strs[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;pos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; chars &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; strs {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; pos {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; idx &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;pos {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; target[idx] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[idx] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>罗马数字转整数</title>
      <link>https://just-worker.github.io/blog/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Thu, 08 Jun 2023 00:06:26 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;罗马数字转整数httpsleetcodecnproblemsroman-to-integer&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/roman-to-integer/&#34;&gt;罗马数字转整数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个罗马数字，将其转换成整数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: s = &amp;ldquo;III&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;正面来看，夹在两个大数之间的小数要减去，太难了；&lt;/p&gt;
&lt;p&gt;反过来看，更大的数字就加上，变小的就减去，线性了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roman_to_int&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::roma_map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; standard) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars().rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch).unwrap().to_owned();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; standard {
                res &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; value;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; value;
            }
            standard &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roma_map&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::new();
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;V&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;L&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;M&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>整数转罗马数字</title>
      <link>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 07 Jun 2023 23:52:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;整数转罗马数字httpsleetcodecnproblemsinteger-to-roman&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/integer-to-roman/&#34;&gt;整数转罗马数字&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个整数，将其转为罗马数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: num = 3&lt;/li&gt;
&lt;li&gt;输出: &amp;ldquo;III&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;数字不大，直接枚举&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int_to_roman&lt;/span&gt;(num: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::roma_map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roma_map&lt;/span&gt;() -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&amp;#39;&lt;/span&gt;static &lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        vec![
            &lt;span style=&#34;color:#75715e&#34;&gt;// 千
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MM&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MMM&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 百
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CD&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;D&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DCCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CM&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 十
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XL&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;L&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LXXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 个
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;II&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;III&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;IV&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;V&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VI&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VII&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VIII&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;IX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;],
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>盛最多水的容器</title>
      <link>https://just-worker.github.io/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 07 Jun 2023 23:39:25 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/container-with-most-water/&#34;&gt;盛最多水的容器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。&lt;/p&gt;
&lt;p&gt;找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;返回容器可以储存的最大水量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;/li&gt;
&lt;li&gt;输出：49&lt;/li&gt;
&lt;li&gt;解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;毋庸置疑，就是使用双指针：总是移动最低的那根线。&lt;/p&gt;
&lt;p&gt;主要问题是，这种直觉需要得到证明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论高低，首先宽度&lt;code&gt;width&lt;/code&gt;一定会变小。
假设最矮的一遍高为&lt;code&gt;h0&lt;/code&gt;，如果移动最高的一遍，新的一遍高&lt;code&gt;h1&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h1 &amp;gt;= h0&lt;/code&gt;: 面积一定是缩小的，因为高还是&lt;code&gt;h0&lt;/code&gt;，但是&lt;code&gt;width&lt;/code&gt;缩小了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h1 &amp;lt; h0&lt;/code&gt; : 面积比原来更小，因为高和宽都缩小了&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，一定只能移动最小的一遍&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max_area&lt;/span&gt;(height: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, height.len() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; width &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; high &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(height[right], height[left]);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; width &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; high;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; area;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; high &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; height[left] {
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>https://just-worker.github.io/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 07 Jun 2023 22:57:00 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>&lt;h2 id=&#34;正则表达式匹配httpsleetcodecnproblemsregular-expression-matching&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/regular-expression-matching/&#34;&gt;正则表达式匹配&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;.&amp;rsquo; 匹配任意单个字符&lt;/li&gt;
&lt;li&gt;&amp;lsquo;*&amp;rsquo; 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a*&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;li&gt;解释：因为 &amp;lsquo;*&amp;rsquo; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;lsquo;a&amp;rsquo;。因此，字符串 &amp;ldquo;aa&amp;rdquo; 可被视为 &amp;lsquo;a&amp;rsquo; 重复了一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;字符串匹配，如果是直接的判断字符相等，或者&lt;code&gt;.&lt;/code&gt;万能匹配都好算，关键是在于&lt;code&gt;*&lt;/code&gt;的后置匹配。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;本身并不进行匹配，它只是传递前一个字符的功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;没有明显的边界限定，理论可以无限延伸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;可以代表0个，也就是含有消除语义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在着手去解题，匹配需要两层循环，那么，谁在外，谁在内呢。不可避免的，我们可能会遇到&lt;code&gt;a*a&lt;/code&gt;这种场景，如果使用匹配字符进行外部循环，会使得我们的匹配场景变得更加的复杂。我们应该&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用相同的匹配字符串，计算可以匹配的多种场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，我们必然要把基础字符串作为外层循环，然后匹配字符串作为内部循环，尽可能的得出一个字符串的多种可能匹配模式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_match&lt;/span&gt;(s: String, p: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; b_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; a_pos &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;a_len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 * ,需要滞后一位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; b_pos &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;b_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果当前是 * 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 消除场景
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos][b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用前一个字符进行比较
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b, a_pos, b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
                        &lt;span style=&#34;color:#75715e&#34;&gt;// 非消除情况下，前面一定经历过了匹配，拿之前匹配结果作为当前匹配结果
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][b_pos];
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b, a_pos, b_pos) {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 直接字符匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[a_len][b_len];
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;match_pos&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, a_pos: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, b_pos: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>回文数</title>
      <link>https://just-worker.github.io/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Wed, 07 Jun 2023 22:48:27 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;回文数httpsleetcodecnproblemspalindrome-number&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/palindrome-number/&#34;&gt;回文数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;例如，121 是回文，而 123 不是。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：x = 121&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;首先，从题目上来说，我们有一些简单的过滤条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负数绝对不是回文数&lt;/li&gt;
&lt;li&gt;大于10切以0结尾的绝对不是回文数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩下的当然可以直接反转之后进行值相等判断，但是这样计算太多了点。假设这个回文数位数是偶数，中途计算过程必然存在两个数字相等，奇数的话除去最后一位判断相等即可。这样，我们就把计算的工作量减半了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// tile: O(len)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_palindrome&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; x {
            reverse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; x;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>字符串转换整数</title>
      <link>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</link>
      <pubDate>Tue, 06 Jun 2023 23:59:17 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;字符串转换整数httpsleetcodecnproblemsstring-to-integer-atoi&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/string-to-integer-atoi/&#34;&gt;字符串转换整数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。&lt;/p&gt;
&lt;p&gt;函数 myAtoi(string s) 的算法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入字符串并丢弃无用的前导空格&lt;/li&gt;
&lt;li&gt;检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。&lt;/li&gt;
&lt;li&gt;读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。&lt;/li&gt;
&lt;li&gt;将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。&lt;/li&gt;
&lt;li&gt;如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。&lt;/li&gt;
&lt;li&gt;返回整数作为最终结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;直接解题就好了，注意其中两个个坑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始解析之后，非数字字符都要中断解析，包括符号位和空格。&lt;/li&gt;
&lt;li&gt;解析开始的标记，可以是数字字符，也可以是符号位。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;my_atoi&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch.is_numeric() {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; ;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; doing {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt; {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; {
                    sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;边界问题，小心检查。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整数反转</title>
      <link>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 06 Jun 2023 23:50:22 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;h2 id=&#34;整数反转httpsleetcodecnproblemsreverse-integer&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/reverse-integer/&#34;&gt;整数反转&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：x = 123&lt;/li&gt;
&lt;li&gt;输出：321&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(LEN) 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; sign;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主要在于边界判断&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N字形变换</title>
      <link>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Tue, 06 Jun 2023 22:49:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      <description>&lt;h2 id=&#34;n字形变换httpsleetcodecnproblemszigzag-conversion&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/&#34;&gt;N字形变换&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &amp;ldquo;PAYPALISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;直接使用模拟的办法进行解析的话，明显会造成空间的浪费，这里就不说了，详细可以看&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/&#34;&gt;官网解答&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;直接计算&#34;&gt;直接计算&lt;/h3&gt;
&lt;p&gt;我们可以思考的是，能够通过数学的规律，直接进行计算。&lt;/p&gt;
&lt;p&gt;分行&lt;code&gt;lines&lt;/code&gt;，明显观察到的规律就是，整个字符周期&lt;code&gt;batch = lines + lines - 2&lt;/code&gt;，其中因为对称的第二列首尾被截取掉了。&lt;/p&gt;
&lt;p&gt;其次，在向上的填充，有对称的部分，很轻易能够计算出，他们的位置其实就是关于&lt;code&gt;lines&lt;/code&gt;的对称。&lt;/p&gt;
&lt;p&gt;现在，分为&lt;code&gt;lines&lt;/code&gt;行，我们直接计算一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![]; lines];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i, ch) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars().enumerate() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; batch;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
                res[idx].push(ch);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res[batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; idx].push(ch);
            }
        }
        res.concat().iter().collect()
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;直接生成&#34;&gt;直接生成&lt;/h3&gt;
&lt;p&gt;直接计算已经非常不错了，核心关系我们也找到了，能够继续优化呢。&lt;/p&gt;
&lt;p&gt;如果我们直接生成结果，而不用借助多个数组，会怎么样子。可以预见的是，我们将遍历不止一次，重复遍历的次数为&lt;code&gt;lines x N&lt;/code&gt;，时间复杂度并不会涨，但是空间复杂度会降低到&lt;code&gt;O(1)&lt;/code&gt;，因为生成的就是结果本身，不算辅助空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; offset &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; batch;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; chars.len()  {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len() {
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset]);
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; offset;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 独行不重复计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len(){
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror]);
                }
                factor &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里主要的变异点在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要重复遍历&lt;code&gt;lines&lt;/code&gt;遍&lt;/li&gt;
&lt;li&gt;有些行的遍历，一个周期内需要添加两个字符&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串2</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</link>
      <pubDate>Mon, 05 Jun 2023 22:55:57 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</guid>
      <description>&lt;h2 id=&#34;前情回顾&#34;&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/&#34;&gt;最长回文子串&lt;/a&gt;中，我们尝试过两种办法去解答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递推：使用空间记录计算过的结果&lt;/li&gt;
&lt;li&gt;扩展：直接扩展计算匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们尝试去解决这两个方案的缺点。在此之前，因为&lt;code&gt;rust&lt;/code&gt;语法和我不想对&lt;code&gt;i32&lt;/code&gt;妥协的原因，前面的&lt;code&gt;expand&lt;/code&gt;方法实现比较扭曲。
为了这次扩展，重写一下&lt;code&gt;expand&lt;/code&gt;，对&lt;code&gt;i32&lt;/code&gt;进行妥协。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;h3 id=&#34;奇偶串&#34;&gt;奇偶串&lt;/h3&gt;
&lt;p&gt;在使用中心扩展的时候，我们需要扩展两次，因为我们不确定它是奇串还是偶串。这里有一个特殊的特性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于奇数串，它的可插入空位是偶数；对于偶数串，它的可插入空位是奇数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个特性，我们可以对原字符串进行空插，最后得出的一定是奇串；最后去剔除掉插入的字符，这样就能够完美解决奇偶串的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这里的#字符并非一定要是原生字符串之外的字符；因为它自带的对称性并不破坏原有数据的对称性；根据它空插的特性，也可以详细的指定移除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算记忆&#34;&gt;计算记忆&lt;/h3&gt;
&lt;p&gt;之前使用递推，结果不仅时间复杂度没有降低，空间复杂度反而更高，这是为什么呢。主要在于遍历的非线性。我们固然在逻辑上创建了一个具有线性关系的递推式，但是实际遍历过程中，为了维护这种逻辑的线性，我们的遍历方式反而是非线性的，这决定了它的时间复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。其次，我们的存储结构，也要求了空间的复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，核心的关系在于，我们能够找出一种线性的遍历关系，让我们既能线性遍历，又能复用计算结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在强制要求线性遍历的场景下，我们先考察一下是否能够有一种办法去传递我们的计算结果。&lt;/p&gt;
&lt;p&gt;对于未遍历导的场景，遍历是必然的。我们假设在遍历到的一个回文串中，关于中心点对称的两个点的性质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为空插字符，始终是奇串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为两个点都是对称的，因此，他们的回文状态必然也是对称的；这样，的确存在了我们可以复用的传递关系。如果对称点不对称，我们必然要重新进行计算，这里当然选用中心扩展的办法。&lt;/p&gt;
&lt;p&gt;这里引申出两个问题：我们需要如何确定这个对称的中心点，我们需要如何利用这个关系进行传导计算。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了尽可能的复用计算结果，需要尽量将要计算的结果包裹在已经计算的范围内，因此，我们需要最靠近右边的中心对称边界&lt;/li&gt;
&lt;li&gt;如果有对称的结果，我们能够确定最小的对称长度就是：对称点的对称长度和当前点到对称边界的长度&lt;/li&gt;
&lt;li&gt;利用中心扩展，对于已知的对称长度，我们可以直接扩展到指定位置，无需重复计算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这三点，我们已经能够解答提出的疑问。但是还有一个问题，那就是用什么数据结构去描述这个对称结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;臂长&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如无必要，勿增实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据奥卡姆剃刀原则，我们最后的结果实际上只和中心扩展的位置相关，只需要一个数据，无需关心具体的字符。其次，利用空插字符后，始终是进行奇串的中心匹配。&lt;/p&gt;
&lt;p&gt;由此，&lt;code&gt;臂长&lt;/code&gt;这个概念应运而生，关于中心点左右对称，单边长度即为&lt;code&gt;臂长&lt;/code&gt;，回文长度就是两倍的臂长加上作为中心字符的长度。&lt;/p&gt;
&lt;p&gt;至此，我们思考并收集了解题的全部要素。&lt;/p&gt;
&lt;h3 id=&#34;马拉车&#34;&gt;马拉车&lt;/h3&gt;
&lt;p&gt;前面的思路全部聚集，就是大名鼎鼎的&lt;a href=&#34;https://baike.baidu.com/item/Manachar%E7%AE%97%E6%B3%95/20415813?fr=aladdin&#34;&gt;Manachar算法&lt;/a&gt;，小名 &lt;code&gt;马拉车&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要分析一下它的复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为要记住已经计算过的臂长的集合，总的就会有&lt;code&gt;N&lt;/code&gt;个元素，&lt;code&gt;O(N)&lt;/code&gt;空间必不可少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要提前申明的是，中心扩展是同时向两边扩展的，如果单边的长度是&lt;code&gt;N&lt;/code&gt;，总数据长度是&lt;code&gt;2N+1&lt;/code&gt;，但是复杂度依旧是&lt;code&gt;O(N)&lt;/code&gt;。因此这里只讨论单向扩展的问题。对于没有计算过的数据，首次计算他会拓展已经记录的右边界。如果对于已经计算过的对称字符内部，可以复用对称边界内的结果，直接推到边界点开始扩展。&lt;/p&gt;
&lt;p&gt;因此，数据的每次扩展，都只会在边界外进行扩展，也就是说，时间复杂度是&lt;code&gt;O(N)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::fill(s);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; arms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; chars.len()];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;chars.len() {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界内
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; current {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; min_arm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(arms[mirror], right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current);
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; min_arm, current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; min_arm);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current, current);
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; right {
                center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current];
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; arms[current];
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界 + 空插字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 空插
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 中心扩展
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 计算臂长
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arm&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::expand(arr, left, right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
    }
      
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;平心静气&#34;&gt;平心静气&lt;/h2&gt;
&lt;p&gt;仔细研读之后，在细细思索，整理出其中思路不难，整理出自己的思路不难。&lt;/p&gt;
&lt;p&gt;面对问题，主要的是分析，依据自身积累的储备，从各方面和角度进行详细的分析，寻求突破。&lt;/p&gt;
&lt;p&gt;可以不会，但是要学会积累。积累到一定程度，就能够解决一些未知但是可以已知的问题了。要保持思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 04 Jun 2023 22:46:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;最长回文子串httpsleetcodecnproblemslongest-palindromic-substring&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-palindromic-substring/&#34;&gt;最长回文子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;babad&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;bab&amp;rdquo;&lt;/li&gt;
&lt;li&gt;解释：&amp;ldquo;aba&amp;rdquo; 同样是符合题意的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;看到这种类似数组的东西，可能第一想法已经是&lt;code&gt;滑动窗口&lt;/code&gt;一类的了，但是仔细想一下，因为是&lt;code&gt;字符串&lt;/code&gt;，我们可能要重复扫描，滑动窗后就不行了。但是对于复用原来计算结果的&lt;code&gt;关系传递&lt;/code&gt;，我们还是可以利用的，这就诞生了第一种解法。&lt;/p&gt;
&lt;h3 id=&#34;dp&#34;&gt;dp&lt;/h3&gt;
&lt;p&gt;因为不可能一次性扫描，为了复用结果而采用&lt;code&gt;dp&lt;/code&gt;，我们可以轻易的得出如下结论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr[i][i]&lt;/code&gt; 单字符串必然是回文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i] == arr[j]&lt;/code&gt;那么，关键就看&lt;code&gt;arr[i+1]&lt;/code&gt;和&lt;code&gt;arr[j-1]&lt;/code&gt;，如果&lt;code&gt;i + 1 = j&lt;/code&gt;，也是回文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的递推关系出现了，但是问题才刚开始：长字符串始终是依赖短字符串的结果的，那么怎么开始遍历呢。&lt;/p&gt;
&lt;p&gt;我们的递推关系式固然是根据子串的边界，但是需要从小的字符串优先计算，因此，必须使用特殊的遍历技巧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; string_length]).collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; sub_length &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; string_length {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[right] {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[left&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                    max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sub_length;
                    begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
                }
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;遍历检测&#34;&gt;遍历检测&lt;/h3&gt;
&lt;p&gt;为什么我们总是去想到一些奇淫技巧呢，可能对于算法题，我们总是感觉有一种&lt;code&gt;技巧性&lt;/code&gt;在里面，否则就无法解题，至少效率不是很高。但是我们在原来的&lt;code&gt;dp&lt;/code&gt;基础上，直接解题会怎么样，我们直接定一个中心，然后向两边进行扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历字符串，定中心&lt;/li&gt;
&lt;li&gt;检测回文，计算结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这似乎更简单，我们尝试一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// spae: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; arr[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; arr[right] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; center &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; odd_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; event_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(odd_length, event_length);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center_length;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (center_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然是笨办法，但是在同等时间复杂度下，不需要借助额外的辅助空间也能够达成目的。也就是说，对于递推类问题，维护关系式第一要素，但是无法做到滑动窗口那种对于元素的一次性计算，有可能还会造成空间的浪费。&lt;/p&gt;
&lt;h2 id=&#34;马拉车&#34;&gt;马拉车&lt;/h2&gt;
&lt;p&gt;明天马拉车，代办&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>感情的失真</title>
      <link>https://just-worker.github.io/blog/%E6%84%9F%E6%83%85%E7%9A%84%E5%A4%B1%E7%9C%9F/</link>
      <pubDate>Sat, 03 Jun 2023 21:17:49 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%84%9F%E6%83%85%E7%9A%84%E5%A4%B1%E7%9C%9F/</guid>
      <description>&lt;h2 id=&#34;真切&#34;&gt;真切&lt;/h2&gt;
&lt;p&gt;毋庸怀疑，感情的初心无谓好坏，只是自己内心中真切的抒发。对一个人的爱或憎，无关事理依据，没有深思熟虑，就是心中直接的反应。对于美景的感叹，对于伤痛的怜悯，对于善良回以真心的接纳。初始状态，就连仇恨也显得可爱。&lt;/p&gt;
&lt;p&gt;得到别人的关爱、善意、帮扶，虽然算不得誓死追随，至少心中的那一份尊敬，让人再开口的时候，已经略带些微&lt;code&gt;谦卑&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;可能&lt;code&gt;谦卑&lt;/code&gt;这个词语过分了些，或者说是&lt;code&gt;和气&lt;/code&gt;？只是没有初始的&lt;code&gt;凌人&lt;/code&gt;，怎么会变得和气；而且和气是氛围，绝不是单方面能够造就的。&lt;/p&gt;
&lt;p&gt;唯一能够确定的是，初始的感情，是如此的真切。只是为什么，人逐渐会变得冷漠，才让&lt;code&gt;感动&lt;/code&gt;成为一种能力；因为漠视，还是因为自己心中那一份对&lt;code&gt;认同&lt;/code&gt;的渴望。&lt;/p&gt;
&lt;h2 id=&#34;冲刷&#34;&gt;冲刷&lt;/h2&gt;
&lt;p&gt;当小孩子说出自己心中的想法和情感，得到的回应是可以预料的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关爱：对于童真的回应，对于梦想的扶持&lt;/li&gt;
&lt;li&gt;敷衍：一时的开心的笑容，自己枯燥生活的放纵&lt;/li&gt;
&lt;li&gt;讥笑：深刻的复杂社会认知，对于无知的冷漠&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使是对于&lt;code&gt;关爱&lt;/code&gt;，对于&lt;code&gt;纯真&lt;/code&gt;的呵护也不是持久的，经过社会的渲染，&lt;code&gt;纯真&lt;/code&gt;也只能是以前，很难继续保持了。&lt;/p&gt;
&lt;p&gt;即使是最开始，从小孩子，纯粹的感情也面临时时刻刻的考验，似乎是对于美的迫害；就算拥有护道者的精心呵护，但是免不了更多的风吹雨打。不由想到，在成长的过程中，成年人的考验是什么呢。&lt;/p&gt;
&lt;p&gt;现如今，逐渐丧失尊重的莫过于&lt;code&gt;教师&lt;/code&gt;了。&lt;code&gt;师者，传道受业解惑者也&lt;/code&gt;。不过可惜的是，三大功能，基本上都是自给自足，可以称别人为师，却非&lt;code&gt;教师&lt;/code&gt;；讽刺的是，即使&lt;code&gt;取之于师&lt;/code&gt;，却总是自视&lt;code&gt;自力更生&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这或许是&lt;code&gt;考验&lt;/code&gt;的一种，众口相传的，这似乎是一种&lt;code&gt;自私&lt;/code&gt;。为自己一人之私，享个人之权，弃社会之责。教师只为谋求己身之福，仅凭授课之公，妄代尊父。社会上大多数的情况似乎都是这样，我们总是觉得别人做的不够好，不够多；都是这种心态的话，哪管真实状态是什么，我自一叶障目。&lt;/p&gt;
&lt;p&gt;所谓的&lt;code&gt;考验&lt;/code&gt;，现如今看来，不若一种&lt;code&gt;迫害&lt;/code&gt;的驱使。固然在艰苦环境中保持本心是一种信仰的坚定，是一种&lt;code&gt;考验&lt;/code&gt;；只是，不至于没有环境还要去创建&lt;code&gt;艰苦&lt;/code&gt;。不算&lt;code&gt;背叛&lt;/code&gt;吧，只是首先要生存，&lt;code&gt;坚定&lt;/code&gt;到底是一种自我的良好品质，还是说被人利用。不由让人怀疑&lt;code&gt;环境&lt;/code&gt;的公正性，更多的人，估计光是关心自己的生存，就已经费劲心思了吧；竭力包住这海量的戾气，没有爆发已经足够克制了。&lt;/p&gt;
&lt;p&gt;那从接触之初，克制戾气已经很不容易了。更不用说那些会产生大量负面情绪的行业了，人的神经时刻都被冲刷，时刻面临考研。&lt;/p&gt;
&lt;h2 id=&#34;麻木&#34;&gt;麻木&lt;/h2&gt;
&lt;p&gt;在丧葬场的人的戾气是否已经足够危害他人了呢，似乎并没有，甚至还能听见欢声笑语；听歌打游戏，娱乐也不会禁绝。这么一想，那救死扶伤的医生们，整天散播善意的天使，岂不是将医院都要打造成人间乐土？似乎也并没有，医院内部的&lt;code&gt;商业往来&lt;/code&gt;，也并非太过遥远的夸夸其谈。&lt;/p&gt;
&lt;p&gt;不由得让人侧目：大量的戾气都足够克制了，何以在频繁勾引人极端情绪的地方，却没有引出更多的破坏，或者美好。&lt;/p&gt;
&lt;p&gt;我贫乏的知识，促使我做出的唯一结论，不过是&lt;code&gt;习以为常&lt;/code&gt;罢了。正如千年以来，人并未发现&lt;code&gt;空气&lt;/code&gt;的存在。习以为常，即使是性命攸关的事情，逐渐的也做到了&lt;code&gt;理所当然&lt;/code&gt;。丧葬场中，对于死亡的适应，已经是生活中和柴米油盐一样的理所当然，不用回避，也不用过于惊奇。医院之中，对于善意约莫也是这样的状态，生老病死都已看淡，悲欢离合也是家常便饭，只有自我的生存才是不变的主题。&lt;/p&gt;
&lt;h2 id=&#34;践踏&#34;&gt;践踏&lt;/h2&gt;
&lt;p&gt;物以稀为贵，习以为常的的东西大抵是一文不值的。常常接收到善意的人，对其本人而言，和掏粪工人脚下的大便一样普遍。成年人都是喜欢可爱的小孩子的，可能是因为见过的可爱不多，也可能是小孩子的难能可贵的童真。只是逐渐的发现其无知对于常识的背离，不仅是毫无用处，只是随着时间的流逝，对于这种&lt;code&gt;无知&lt;/code&gt;的习以为常，逐渐的失去耐心，也造就了自身的&lt;code&gt;傲慢&lt;/code&gt;。只有经过长时间的平复，和生活中事实的积累，经历孩子的&lt;code&gt;反叛&lt;/code&gt;，逐步达成&lt;code&gt;和解&lt;/code&gt;，最后发出廉价的老生常谈的父母的&lt;code&gt;欣慰&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有一些偏颇，却不失一丝真实。因为如此，善人大抵是感受不到善的；恶人也没有觉得自己在作恶罢。都是些习以为常的事情。当医生面对家人的感谢地时候，可能只是厌烦，因为他还忙着回家；当恶人面对求饶声的时候，估计也毫无所动，这不过是每个受害者千篇一律的模板行为。三体中的圣母犯下的错误，那就是认为和平理所当然。&lt;/p&gt;
&lt;p&gt;理所当然得事情并不存在，&lt;code&gt;宗教&lt;/code&gt;、&lt;code&gt;战争&lt;/code&gt;、&lt;code&gt;爱情&lt;/code&gt;的存在一再表明，人并不是什么理智的生物。所以理所当然当然是理所当然的。&lt;/p&gt;
&lt;h2 id=&#34;失真&#34;&gt;失真&lt;/h2&gt;
&lt;p&gt;当一个服务员不再去发觉客户的需求的时候，只是机械的执行者作为侍者的引导；甚至丢失侍者的身份，示之以人的是引导者的傲慢；我们需要如何以何种面目，何种感情，何种手段去面对他们。正如前面所说的已经&lt;code&gt;麻木&lt;/code&gt;的人们。&lt;/p&gt;
&lt;p&gt;心里好像有了答案：非真切的感情，不以感情回应。&lt;/p&gt;
&lt;p&gt;理所当然的是，人并非什么理智的生物。对于结论的执行，最终不过也会成为一种形式化的理所当然。对于非真切的教师的漠视，逐渐的变为对于教师的漠视，丢失对于&lt;code&gt;传授&lt;/code&gt;的回应。即使怀着坚定的想法，对一切感情一一回应，理所当然的，最终只会变成千篇一律的形式化。&lt;/p&gt;
&lt;p&gt;感情是不只是发起，它还需要回应；感情是需要传导的。不过现在看来，它失真了；传导过程中，因为成年累月形成的社会规则，一些形态的感情的形式化，使得感情的传导失真了。不管是处于什么样的目的，还是什么样的场景，作为什么样的角色，不可避免的，失真了。&lt;/p&gt;
&lt;h2 id=&#34;规矩&#34;&gt;规矩&lt;/h2&gt;
&lt;p&gt;真切的感情，导致真切的心伤；更多的感情倾注，只会遭遇更多的扭曲。关爱会变成奉承，奉承变成卑微，卑微导致驱使，舔狗最终一无所有？只能说轻易得来的东西，无人感受得到它的分量。无人知晓的感动，无人反抗的暴动，无知导致不合理的东西充斥社会，导致更大的失真。再坚定的人，也会变得麻木。不至于扭曲，但是我们也只能把外壳变得逐渐的坚硬，保留下核心的信仰，不再追求尽善尽美，不再深究细枝末节。&lt;/p&gt;
&lt;p&gt;千万年，千万智者形成的社会，形成了一些无情的规则。我们不至于超越，不过经历初期的怀疑，现在也只能是接受这些规则了。感情这种事情，真的只能放下了；即使是自己情绪，但是也要知道情绪这回事，也是毫无必要的了；一旦发起，只会到达错误的终点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天若有情天亦老，人间正道是沧桑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是时候该沧桑起来了，年轻时候要&lt;code&gt;想&lt;/code&gt;，年轻不再，该&lt;code&gt;做&lt;/code&gt;了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数2</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</link>
      <pubDate>Fri, 02 Jun 2023 20:51:49 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</guid>
      <description>&lt;h2 id=&#34;紧跟上文&#34;&gt;紧跟上文&lt;/h2&gt;
&lt;p&gt;紧跟上文&lt;a href=&#34;https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;，在二分之后，继续深入。&lt;/p&gt;
&lt;h2 id=&#34;原理分析&#34;&gt;原理分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;中位数: 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的分析可以从&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&#34;&gt;官网解析&lt;/a&gt;找到详细的论述，我这里就不多费唇舌。&lt;/p&gt;
&lt;p&gt;结论就是，针对数组&lt;code&gt;a&lt;/code&gt;选取坐标&lt;code&gt;i&lt;/code&gt;，对于数组&lt;code&gt;b&lt;/code&gt;选取坐标&lt;code&gt;j&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt; : &lt;code&gt;a[0..i] + b[0..j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt; : &lt;code&gt;a[i..] + b[j..]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max(left) &amp;lt;= min(right)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt; a_len, 0 &amp;lt;= j &amp;lt; b_len, i + j = (a_len + b_len + 1) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 i + j 公式来自于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总长偶数: &lt;code&gt;left.len == right.len&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总长奇数: &lt;code&gt;left.len = right.len + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，换算成等式关系之后，我们只需要检索其中一个数组之后，就可以得出结论了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(min(M, N)))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(a: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#75715e&#34;&gt;// 始终保证 a 长度小于 b
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; b_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::find_median_sorted_arrays(b, a);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, a_len);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_max, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_min) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 检索
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分检索 i
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 计算对应的 j 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i;
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i-1] 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j-1]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// 满足条件，非最大 i ,向右查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; b_j {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 左侧数组的最大值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                a_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::max(a_i_prev, b_j_prev);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 右侧数组的最小值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                b_min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_i, b_j);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向右推进
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { 
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向左查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 左侧 多收容，中位数就是左侧最大数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            a_max &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 双边界平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            (a_max &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_min) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;降维打击&#34;&gt;降维打击&lt;/h2&gt;
&lt;p&gt;看完之后，只能说要常复习，常练习，只能看懂却不能掌握，实在太遗憾。&lt;/p&gt;
&lt;p&gt;同时，有两个启发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另辟蹊径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题中，从另一个角度去分析题目，把一道&lt;code&gt;搜索题&lt;/code&gt;变成了一道&lt;code&gt;计算题&lt;/code&gt;。虽然还是有搜索的部分，但是更偏向于&lt;code&gt;计算+匹配&lt;/code&gt;了，比起之前的简单计算+复杂搜索，把搜索的复杂度，向计算过度，从而达到足够优化的算法复杂度；进一步对原有的实现方法形成降维打击。&lt;/p&gt;
&lt;p&gt;一方面，可以说是思维的精妙。一般时间复杂度的降低，除了大量空间的牺牲可以提高，剩下的只能够凭借精妙的算法得以达成。&lt;/p&gt;
&lt;p&gt;另一方面，则是思维上的开拓。不仅仅是对于思维的跳脱，还需要有开阔的眼界，否则，何来的素材；多积累才有的多选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系传导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多事情，哪怕算法，只有抓到核心关键，才能够事半功倍。正如斐波那契，正如汉诺塔。如果只是一昧的暴力，总有碰壁的时候。同样是规律，越是接近事物的本质，效率也来的更加的快速；刨除了无用的损耗，效率自然成倍的提高。&lt;/p&gt;
&lt;p&gt;越来越相信大道至简，因为越是了解越多，越是接近本质，如此的简单，威力却如此的巨大。降维打击，莫过如此。&lt;/p&gt;
&lt;p&gt;的确，如果真的想要时时顺心，事事如意，我们必须要提高我们的效率，去达成面临的事情；但是面临的事情逐渐的庞大，我们的效率不能只是&lt;code&gt;速度&lt;/code&gt;，还要有&lt;code&gt;质量&lt;/code&gt;，快速的，摧枯拉朽的去解决掉阻碍的事情，这才是我们需要积累的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Thu, 01 Jun 2023 22:51:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度应该为 O(log (m+n)) 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums1 = [1,3], nums2 = [2]&lt;/li&gt;
&lt;li&gt;输出：2.00000&lt;/li&gt;
&lt;li&gt;解释：合并数组 = [1,2,3] ，中位数 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;数组的中位数，值的一提的就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组长度是奇数，中位数就是有序数组的最中间的值&lt;/li&gt;
&lt;li&gt;如果数组长度是偶数，中位数就是有序数组中间两个值的平均&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算过程中，假设排序数组为&lt;code&gt;arr&lt;/code&gt;，数据长度为&lt;code&gt;len&lt;/code&gt;，中位数表示如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组长度为奇数: &lt;code&gt;arr[len / 2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组长度为偶数: &lt;code&gt;(arr[len / 2] + arr[len / 2 + 1]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然是分支逻辑，但是通过特殊的计算，我们可以合并为相同的逻辑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(arr[(len + 1) / 2] + arr[(len + 2) / 2]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就能够更简单的进行问题的求解。&lt;/p&gt;
&lt;p&gt;本题目求解不难，难点在于&lt;code&gt;O(log(m + n))&lt;/code&gt;的时间复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于合并之后直接求解的办法已经说明，这里专注其他技巧求解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h3&gt;
&lt;p&gt;目前滑动窗口的出镜率极高，这道题也可用滑动窗口进行求解。并且和之前的&lt;code&gt;缓存&lt;/code&gt;有很大的区别，&lt;code&gt;窗口&lt;/code&gt;本身的概念也于抽象。&lt;/p&gt;
&lt;p&gt;其实找到中位数，并不一定需要合并到同一个数组，使用两个指针维护查找的队列，其实就可以达到同样的目的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M + N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nums1.len(), nums2.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_idx, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_idx) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; current, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums1[a_idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums2[b_idx] {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; ) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;二分法&#34;&gt;二分法&lt;/h3&gt;
&lt;p&gt;其实对于&lt;code&gt;O(log(m + n))&lt;/code&gt;的第一反应，必定就是二分法，关键在于如何构造二分。&lt;/p&gt;
&lt;p&gt;这里其实有一个很细微的理解问题，正如&lt;code&gt;三&lt;/code&gt;在古文中表示的意思是&lt;code&gt;多&lt;/code&gt;，而非真的是&lt;code&gt;3&lt;/code&gt;。所谓的二分法，并非严格意义上的丛中分断，它不仅可以是&lt;code&gt;1/n&lt;/code&gt;，甚至在一些边界条件中，也是允许不严格的划分的。尤其是其中的&lt;code&gt;O(log(m + n))&lt;/code&gt;，底数并没有固定展示，这只是一种表示方法，一种趋势，如果是&lt;code&gt;1/n&lt;/code&gt;分，底数不过就变成了&lt;code&gt;n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;说到这里，结合前面的方法，其实我们已经掌握了核心的办法，这要从两个问题进行引申&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是单个数组的话，直接通过计算就可以得出结果，但是我们为什么需要进行查找。查找其实只是为了区分两个数组之间的关系，而对于一个数组中的中位数，我们可以直接计算出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于滑动窗口的优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，边界情况下，只剩下了一个数组，我们可以直接进行计算，而非继续傻傻的一个个查找。但是为什么会到这一步呢，因为我们&lt;code&gt;排除&lt;/code&gt;了其中一些非法的答案。查找类的问题经常有两种办法进行求解，正向的匹配检查，和反向的非法排除。常用的二分法，其实就是在规则匹配的条件下对空间进行排除，并且排除优先于匹配。可能对于经典的二分法而言，每一步空间的缩小似乎都是正向的匹配，但其实排除大量的干扰，才是二分的要义。&lt;/p&gt;
&lt;p&gt;可能相较于单个数组的精准匹配，排除似乎更废时间；但是对于本题中类似的模糊区间查找，排除才是王道。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(m+n))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums2.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 两数平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, left) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, right)) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_nth&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, k: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_begin, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_begin) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 单边直接计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; b[b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;b_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a[a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cmp::min(a[a_begin], b[b_begin]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分移除： 因为对于half而言是可以稳定移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; half &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界条件下非二分移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, a_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 降低 k 缩小边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a[next_a_begin] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; b[next_b_begin] {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二分之所以威力巨大，其实是因为它只用判断一半的元素，正如我们查找中位数，正向查找完全不好关心后半截的数据一样。&lt;/p&gt;
&lt;h3 id=&#34;反向排除&#34;&gt;反向排除&lt;/h3&gt;
&lt;p&gt;在迷茫的时候，缺乏正确的指引，盲目的追求正确，试错成本很高，而且可能要经受多次的失败。但如果是深思熟虑，通过少数的关键特征，些许的试错然后去排除错误的选项，这就能让我们更快，更有效的找到正确的选项。&lt;/p&gt;
&lt;p&gt;学习算法，学会高效的处理的方式，同样可以使用于人生。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串</title>
      <link>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 31 May 2023 23:04:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&#34;&gt;无重复字符的最长子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: s = &amp;ldquo;abcabcbb&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;li&gt;解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;对于这种基础的题目，爆破始终是第一选项。如果有过更近一步的经验，感觉也能和递推产生一些关系。但是首选项必然是&lt;code&gt;滑动窗口&lt;/code&gt;。
&lt;code&gt;滑动窗口&lt;/code&gt;其实没有什么高深的原理，只是维护一个动态的窗口条件，通过边界的缩放，判断、修改窗口内的数据关系。不过是看起来像窗口而已，我更宁愿把它归纳为之前提炼出来的&lt;code&gt;关系传导&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然是使用&lt;code&gt;缓存&lt;/code&gt;的，但是这所谓缓存的结果，隐含了之前计算的元素之间的微妙联系。滑动窗口也是如此，它通过窗口边界的收缩，把某种关系限定在窗口数据内，当我们进行新一轮的判断的时候，&lt;code&gt;关系&lt;/code&gt;的传导让我们不必关心更多的干扰，从而去针对的制定逻辑。把纷繁的问题逐步拆分，这样就使得求解变得简单、清晰。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) 需要遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(X) 字符集长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashSet;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;length_of_longest_substring&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; container &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashSet::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[right];
            &lt;span style=&#34;color:#75715e&#34;&gt;// 剔除重复字符串
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; container.contains(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[left];
                container.remove(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;left_char);
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 窗口内有效字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            container.insert(ch);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; container.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; container.len();
            }
        }
        res &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基础维护&#34;&gt;基础维护&lt;/h2&gt;
&lt;p&gt;我们为什么需要学习，因为我们想具备某种能力，从而让自己变得更加的自由。&lt;/p&gt;
&lt;p&gt;这里隐含了一种关系，&lt;code&gt;维护&lt;/code&gt;和&lt;code&gt;使用&lt;/code&gt;。学习红黑树的时候，让我十分厌倦；不论是各种旋转还是条件、染色，只是让我觉得啰嗦。我觉得学习这种东西，除了应付差事，我大概永远和它无缘。后面知晓数据库使用了树结构，其实我也有一种想法，觉得数据库简直多余。的确，&lt;code&gt;维护&lt;/code&gt;是无用的，耗时且费力的，默默无闻一辈子，可能光辉的一瞬都不一定能换回来。&lt;/p&gt;
&lt;p&gt;但是，俗话说得好，&lt;code&gt;一口吃不成&lt;/code&gt;胖子。想要成为胖子，那是需要&lt;code&gt;日积月累&lt;/code&gt;的，&lt;code&gt;水滴石穿，非一日之功&lt;/code&gt;。面对一些事情，我们的能力，我们的选择，并不能&lt;code&gt;一蹴而就&lt;/code&gt;。正如使用数据库，尽管实现很麻烦，使用&lt;code&gt;SQL&lt;/code&gt;也不简单，但是面对海量的数据的时候，我们能够轻易的完成查找、聚合、排序等操作。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。显而易见的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比起瞬间聚集的能力，维护是小步的、简单的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;我这一拳二十年的功力，你挡得住么&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;正如扭螺丝的奇葩账单，有些简单的事情背后真的很不简单。为什么不同岗位的工资差别如此的巨大，仅仅是因为工作内容的不一致么。并不是，而是来源于工作能力的培养难度。学了二十年才能出师的岗位，显然比学习一周上岗的岗位薪酬高的多。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。短小的时日并不能集聚太多的知识。&lt;/p&gt;
&lt;p&gt;这也正是要专心写博客的原因，没有之一。你想有的能力，需要维护。维护的多好，当你使用的时候就能发挥多大的效果。比起完成瞬间积聚巨大能量的不可能，水滴石穿、细水长流的积累，显得如此的轻松。请放心，付出终究会有收获，如果每一份耕耘都太过艰难，那只是预示你将会有巨大的丰收。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数相加</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Tue, 30 May 2023 22:55:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>&lt;h2 id=&#34;两数相加httpsleetcodecnproblemsadd-two-numbers&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/add-two-numbers/&#34;&gt;两数相加&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：l1 = [2,4,3], l2 = [5,6,4]&lt;/li&gt;
&lt;li&gt;输出：[7,0,8]&lt;/li&gt;
&lt;li&gt;解释：342 + 465 = 807.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;逐位相加，算是最简单的办法了；当然，也可以转换成数字后相加，但是如果数据溢出，也会有问题。&lt;/p&gt;
&lt;p&gt;本题最关键的，就是如何计算&lt;code&gt;进位&lt;/code&gt;。当然，谁都能看出来，但是最关键有如下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位数补齐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果其中一个链表用完了该怎么办呢，可能大多数人直接反应就是将后续的列表进行拼接，容易忽略进位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算出的结果也不一定就是和最大输入同长度的，额外的进位需要再后面进行补足。&lt;/p&gt;
&lt;p&gt;和上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/&#34;&gt;两数之和&lt;/a&gt;一样，所谓进位，也可以算得上一种关系的固化和传递，虽然很浅显，但是需要继续保有这种意识，才能逐步加深认知，才能敏锐的发现一些相似的东西。&lt;/p&gt;
&lt;h3 id=&#34;原始解题&#34;&gt;原始解题&lt;/h3&gt;
&lt;p&gt;先用最简单的办法实现一遍。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; l1.is_some() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; l2.is_some() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l1.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.unwrap();
                a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l2.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2.unwrap();
                b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        }
        res
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l1, l2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// (list1, list2, sum, carry)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; data {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 无数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;,
                &lt;span style=&#34;color:#75715e&#34;&gt;// 直接进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; (None, None, carry, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;),
                &lt;span style=&#34;color:#75715e&#34;&gt;// 其中一个有数据，且能进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(list), None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(list), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (list.next, None, sum, c)
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 两个数进位加法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(l1), Some(l2), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; l2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (l1.next, l2.next, sum, c)
                }
            };

            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(data.&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        res
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;递归处理&#34;&gt;递归处理&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        Self::add_two_numbers_recursive(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, last, l1, l2);
        res
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers_recursive&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, last: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (l1, l2, carry) {
            (None, None, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))),
            (Some(node), None, _) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(node), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node.next, None);
            },
            (Some(node1), Some(node2), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; node2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node1.next, node2.next);
            },
            _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {}
            
        }  
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;优化处理&#34;&gt;优化处理&lt;/h2&gt;
&lt;p&gt;关于这个问题的主体，还是在&lt;code&gt;进位&lt;/code&gt;的计算，不论是只剩下单边数据了还能继续进位，还是说溢出产生的额外进位。&lt;/p&gt;
&lt;p&gt;虽然问题的核心得到了解决，不过还有几个方面让我们的方案变得更好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面虽然说了即使单边数据也能连续进位，但是对于不可进位的单边数据，可以采取直接嫁接的方法，提前结束判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原地相加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以不利用额外的数据结构，直接以单边数据为容器进行相加。不过这种方式还是避免不了进位溢出和选取了数据较短的一方，空间复杂度还是一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数之和</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 29 May 2023 23:31:46 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;两数之和httpsleetcodecnproblemstwo-sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/two-sum/&#34;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标值 &lt;code&gt;target&lt;/code&gt;  的那两个整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [2,7,11,15], target = 9&lt;/li&gt;
&lt;li&gt;输出：[0,1]&lt;/li&gt;
&lt;li&gt;解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;h3 id=&#34;爆破&#34;&gt;爆破&lt;/h3&gt;
&lt;p&gt;对于这道题，粗暴的求解方式就是对于数组中的的两两组合求值，从而判断结果是否符合答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2) : 最坏情况需要遍历全部可能配对
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)  : 无额外空间消耗
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; , j &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;];
                }
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;按图索骥&#34;&gt;按图索骥&lt;/h3&gt;
&lt;p&gt;这里有两个特殊的视角&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于确定等式的三个数值，我们只要确定了其中两个，就能够唯一确定第三个&lt;/li&gt;
&lt;li&gt;可以列一个清单去进行匹配，而不是每次都需要重新计算(缓存)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质的核心，其实就是等式关系的延续，把一个&lt;code&gt;满足等式的数&lt;/code&gt;的判断，转化为&lt;code&gt;某个确定的数&lt;/code&gt;的限定条件。&lt;!-- raw HTML omitted --&gt;
更关键的是，对于&lt;code&gt;target&lt;/code&gt;和&lt;code&gt;nums[?]&lt;/code&gt;的依赖，做了一个特殊的持久化，不用每次计算都携带，降低了信息传递的消耗。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) : 只用遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N) : 最坏情况首尾相加
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; last.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![last.unwrap().to_owned(), index];
            }
            map.insert(target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; value, index);
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关键技巧&#34;&gt;关键技巧&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;缓存&lt;/code&gt;固然是一个关键的技巧，但是我更宁愿把&lt;code&gt;固化&lt;/code&gt;称为其中核心秘籍。&lt;/p&gt;
&lt;p&gt;正是因为&lt;code&gt;固化&lt;/code&gt;了其中的计算关系，&lt;code&gt;缓存&lt;/code&gt;才能发挥更大的能力。
所谓&lt;code&gt;缓存&lt;/code&gt;，其实就是耗费资源去得到的一个结果，当我们重复的去获取这个结果的时候，使用已经计算好的副本，能够极大的避免计算的开销。
因此，在涉及重复计算的场景下，缓存有很大的作用空间；但是，&lt;code&gt;固化&lt;/code&gt;作为其核心要义，并非只是简单的存储结果。
一个计算结果本身就有来由的原因。&lt;/p&gt;
&lt;p&gt;本题中，正式因为把算式的因果关系转换，并且利用缓存进行&lt;code&gt;固化&lt;/code&gt;，把查找转换为匹配，才根源上完成解题的突破。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记录的必要</title>
      <link>https://just-worker.github.io/blog/%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BF%85%E8%A6%81/</link>
      <pubDate>Sun, 28 May 2023 23:41:19 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BF%85%E8%A6%81/</guid>
      <description>&lt;h2 id=&#34;为什么记录&#34;&gt;为什么记录&lt;/h2&gt;
&lt;p&gt;今天突然有一个感悟：先有的目的，然后有的方法。或者说，因为想，所以成。虽然有点心想事成的玄学，但事实的确如此。&lt;/p&gt;
&lt;p&gt;生活之中，别人向你求解某些东西的时候，别人弄不明白，反而说你讲不清楚；这让人十分的气愤。不过，有些人，的确也会，却热衷于让人弄明白，也让我感叹：这真是十足的叛徒。
不论他背叛的了什么，但是后续一种称为&lt;code&gt;沟通技巧&lt;/code&gt;的东西的确的会流传开，正如开发背叛了技术，去舔了产品，从而出现了&lt;code&gt;DDD&lt;/code&gt;。开个玩笑，不过事实的确如此。抛开主观的臆想和情绪，真正的投入到关注的东西上面去，才会真的衍生出某种超脱的东西，而非局限于现状。终究，研究的东西终会明了，阻碍的问题也会得以解决。&lt;/p&gt;
&lt;p&gt;这对于我而言，真的十分重要，至少，我发现很多时候我都在原地踏步。谈不上刻苦，算不上勤勉，也不是懒惰，我还是有一点点的努力的。只是偶尔回顾的时候，我发现我始终在重复。之前我的观点是，&amp;ldquo;脚踏实地，一步一步&amp;rdquo;，但是一直没能前进。后来，我想的是先探路，再夯实，结果是脚步虚浮。现在，我不知道我经历过什么，也说不清我将要遭遇什么，对于过去和现在以及将来，似乎有所感，却朦朦胧胧。&lt;/p&gt;
&lt;p&gt;这就是我现在面临的最大的问题：不清晰。&lt;/p&gt;
&lt;p&gt;必定是有什么办法去解决的，只要我真的关注这件事情，不分心，也不推辞的话。过去的学习，思考和经验，由于没有进一步的归纳和总结，它们就消逝得无影无踪，但的确的曾经出现过。
这是必然是让人恍惚的，当再次回忆的时候，那种朦胧和迷离，给不了当下的我一种明晰的回馈。由此，它给我带来了一些盲目的自信，因为一个圆满的成功，一个失误都消逝了的单纯的结果；它也给我带来更多惶恐的自卑，因为一个虚浮的结果，一个没用具体支撑的空中楼阁。这种糟糕的心灵折磨，每天都轮番上阵。尤其是当我正投入的学习的时候，总是会回想起我上一次的学习，明白的告诉我，这的确是我对于同样的东西的不只一次的学习，明确的表明，我仍然没有学会，以及领悟更多的东西。&lt;/p&gt;
&lt;p&gt;势必要让它变得更明白一些了。让一些念头，真切的坦露；让一些学习，镌刻心头；让一些妄念，剥离开来。我想当我谈及某种东西的时候，我能够清晰的回忆起细节；记忆固然是不可靠的，那我也能找到我当时的领悟。简而言之，我想让将来的我，能够稳定且准确的回到我当前的状态；只有这样，我才能够为自己的努力自豪；也才能够依循上次的脚步，继续加深，而非从头来过。&lt;/p&gt;
&lt;p&gt;那就详细的记录下来，关于自己的学习，自己的思想。把真实留住，把妄想驱逐。&lt;/p&gt;
&lt;h2 id=&#34;记录些什么&#34;&gt;记录些什么&lt;/h2&gt;
&lt;p&gt;从我现在的需求，应该能够确定我将来需要回溯的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我想发挥的时候，我能分辨我是否有(过)这种能力&lt;/li&gt;
&lt;li&gt;当我想学习的时候，我能知晓我的学习程度&lt;/li&gt;
&lt;li&gt;当我想规划的时候，我能权衡我的知识储备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，我应该详尽的去记录自己想要回溯的状态，尽量的表明我所掌握的知识，体现我掌握的程度。不要夸大，也不要遗漏，即使是错误的也不要紧，后续我也能够发现自己的更正(进步)。&lt;/p&gt;
&lt;p&gt;回到之前所说的感悟，套用到我当前的状态。正式因为要解决我当前的迷茫状态，我才需要去分析和关注我当前的行为。可能不能够马上达到正确的结果，但是我需要继续专注。&lt;/p&gt;
&lt;h2 id=&#34;记录的规则&#34;&gt;记录的规则&lt;/h2&gt;
&lt;p&gt;即使当前只有一个模糊的想法，但是把它逐渐清晰的雕刻出来，才是最终的目的。因此，需要一些限制，防止懒散入侵，让此刻的想法得以坚持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每天都要记录
这是最基础的点了，我觉得要必要保持每天的思考。顶层设计，自上而下的倒逼的话，就是每天都需要记录，以此来强迫自己每日对于思考的追逐。&lt;/li&gt;
&lt;li&gt;非发泄的记录
记录的东西可以是学习，可以是回忆，可以是感想，唯独不能是单纯的情绪发泄。记录将是一种旅行，每一步都将是脚印，让脚印清晰，让脚印整齐，让脚印前进这才有记录的意义。纯粹的情绪发泄，正如原地踏步，它无法深刻任何东西，感受不到任何具体，不能让人前进。&lt;/li&gt;
&lt;li&gt;清晰的分类
记录的范围的确过于宽泛了，但是目前也不能够约定的足够详细，那样就抹灭了灵性。因此，对于宽泛的记录，有必要分门别类的进行整理，需要慎重、清晰的对文章进行标记整理。&lt;/li&gt;
&lt;li&gt;准确且详细的表达
记录不仅仅是给自己带来自信，不可否认的一点，将来某一时刻，它必将被查看，或者说，我们都将回到现在。因此，关于现在的记录，势必要有一定的详尽且真实的记载。在将来的某一刻，我们才能够准确无误的抵达现在，没有虚假，也没有确实，完整的回来。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>再一次开始</title>
      <link>https://just-worker.github.io/blog/%E5%86%8D%E4%B8%80%E6%AC%A1%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sat, 27 May 2023 21:17:35 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%86%8D%E4%B8%80%E6%AC%A1%E5%BC%80%E5%A7%8B/</guid>
      <description>&lt;h2 id=&#34;赏心悦目的博客&#34;&gt;赏心悦目的博客&lt;/h2&gt;
&lt;p&gt;从最开始的 &lt;code&gt;csdn&lt;/code&gt;，后面的 &lt;code&gt;gitPages&lt;/code&gt; ，后续自建的 &lt;code&gt;hexo&lt;/code&gt;。不断来回反复，却始终原地踏步。
我不太确信博客的定义，我只是希望它&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无广告&lt;/li&gt;
&lt;li&gt;简洁轻便明了&lt;/li&gt;
&lt;li&gt;公网访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以此去规范自己逐步的学习、记录进步。&lt;/p&gt;
&lt;p&gt;现在，我大概找到了最中意的样式和方式了。剩下的，只能是向内求取了，也杜绝了分神的接口。&lt;/p&gt;
&lt;h2 id=&#34;迟迟未到的觉悟&#34;&gt;迟迟未到的觉悟&lt;/h2&gt;
&lt;p&gt;一直都是觉得，&lt;code&gt;只有...我才能...&lt;/code&gt;。这么一个欺骗自己的句式，因为之前的太多铺垫造就的顺风，让我沉迷太久。
现在也算是划一个句号吧。年龄比觉悟早早的就到了，我也不确定这个觉悟能够持续多久。可能过不了多久就会消散，也没有确切的方法一直维持；唯一能做的，就是应该把当前想做的做到，让后续的努力不再重复，得以到达更远的地方。&lt;/p&gt;
&lt;h2 id=&#34;稳稳当当的以后&#34;&gt;稳稳当当的以后&lt;/h2&gt;
&lt;p&gt;不一定是稳定的，可能也会继续波折。
只是对个人而言，我希望今后能够稳定一点。学习和积累方面吧，其他方面个人说了也不算。
今后博客这条路也就不再重复了，也不找借口挥霍时间和精力了。&lt;/p&gt;
&lt;p&gt;记录生活，记录学习，记录人生；从现在开始。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>just-worker</title>
    <link>https://just-worker.github.io/</link>
    <description>Recent content on just-worker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 08 Jun 2023 00:06:26 +0800</lastBuildDate><atom:link href="https://just-worker.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>罗马数字转整数</title>
      <link>https://just-worker.github.io/blog/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Thu, 08 Jun 2023 00:06:26 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;罗马数字转整数httpsleetcodecnproblemsroman-to-integer&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/roman-to-integer/&#34;&gt;罗马数字转整数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个罗马数字，将其转换成整数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: s = &amp;ldquo;III&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;正面来看，夹在两个大数之间的小数要减去，太难了；&lt;/p&gt;
&lt;p&gt;反过来看，更大的数字就加上，变小的就减去，线性了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roman_to_int&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::roma_map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; standard) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars().rev() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch).unwrap().to_owned();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; standard {
                res &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; value;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; value;
            }
            standard &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roma_map&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::new();
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;V&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;L&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;);
        res.insert(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;M&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>整数转罗马数字</title>
      <link>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 07 Jun 2023 23:52:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;整数转罗马数字httpsleetcodecnproblemsinteger-to-roman&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/integer-to-roman/&#34;&gt;整数转罗马数字&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个整数，将其转为罗马数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: num = 3&lt;/li&gt;
&lt;li&gt;输出: &amp;ldquo;III&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;数字不大，直接枚举&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int_to_roman&lt;/span&gt;(num: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::roma_map();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]);
        res.push_str(map[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;][num &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roma_map&lt;/span&gt;() -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&amp;#39;&lt;/span&gt;static &lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        vec![
            &lt;span style=&#34;color:#75715e&#34;&gt;// 千
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MM&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MMM&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 百
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CD&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;D&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DCCC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CM&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 十
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XL&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;L&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LXXX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;],
            &lt;span style=&#34;color:#75715e&#34;&gt;// 个
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;II&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;III&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;IV&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;V&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VI&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VII&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VIII&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;IX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt;],
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>盛最多水的容器</title>
      <link>https://just-worker.github.io/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 07 Jun 2023 23:39:25 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/container-with-most-water/&#34;&gt;盛最多水的容器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。&lt;/p&gt;
&lt;p&gt;找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;返回容器可以储存的最大水量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;/li&gt;
&lt;li&gt;输出：49&lt;/li&gt;
&lt;li&gt;解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;毋庸置疑，就是使用双指针：总是移动最低的那根线。&lt;/p&gt;
&lt;p&gt;主要问题是，这种直觉需要得到证明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论高低，首先宽度&lt;code&gt;width&lt;/code&gt;一定会变小。
假设最矮的一遍高为&lt;code&gt;h0&lt;/code&gt;，如果移动最高的一遍，新的一遍高&lt;code&gt;h1&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h1 &amp;gt;= h0&lt;/code&gt;: 面积一定是缩小的，因为高还是&lt;code&gt;h0&lt;/code&gt;，但是&lt;code&gt;width&lt;/code&gt;缩小了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h1 &amp;lt; h0&lt;/code&gt; : 面积比原来更小，因为高和宽都缩小了&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，一定只能移动最小的一遍&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max_area&lt;/span&gt;(height: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, height.len() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; width &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; high &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(height[right], height[left]);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; width &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; high;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; area &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; area;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; high &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; height[left] {
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                right &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>https://just-worker.github.io/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 07 Jun 2023 22:57:00 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>&lt;h2 id=&#34;正则表达式匹配httpsleetcodecnproblemsregular-expression-matching&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/regular-expression-matching/&#34;&gt;正则表达式匹配&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;.&amp;rsquo; 匹配任意单个字符&lt;/li&gt;
&lt;li&gt;&amp;lsquo;*&amp;rsquo; 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a*&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;li&gt;解释：因为 &amp;lsquo;*&amp;rsquo; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;lsquo;a&amp;rsquo;。因此，字符串 &amp;ldquo;aa&amp;rdquo; 可被视为 &amp;lsquo;a&amp;rsquo; 重复了一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;字符串匹配，如果是直接的判断字符相等，或者&lt;code&gt;.&lt;/code&gt;万能匹配都好算，关键是在于&lt;code&gt;*&lt;/code&gt;的后置匹配。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;本身并不进行匹配，它只是传递前一个字符的功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;没有明显的边界限定，理论可以无限延伸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;可以代表0个，也就是含有消除语义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在着手去解题，匹配需要两层循环，那么，谁在外，谁在内呢。不可避免的，我们可能会遇到&lt;code&gt;a*a&lt;/code&gt;这种场景，如果使用匹配字符进行外部循环，会使得我们的匹配场景变得更加的复杂。我们应该&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用相同的匹配字符串，计算可以匹配的多种场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，我们必然要把基础字符串作为外层循环，然后匹配字符串作为内部循环，尽可能的得出一个字符串的多种可能匹配模式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(MN)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_match&lt;/span&gt;(s: String, p: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; b_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; a_pos &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;a_len {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 * ,需要滞后一位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; b_pos &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;b_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果当前是 * 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 消除场景
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos][b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用前一个字符进行比较
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b, a_pos, b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
                        &lt;span style=&#34;color:#75715e&#34;&gt;// 非消除情况下，前面一定经历过了匹配，拿之前匹配结果作为当前匹配结果
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][b_pos];
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Self::match_pos(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b, a_pos, b_pos) {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// 直接字符匹配
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    dp[a_pos][b_pos] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[a_len][b_len];
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;match_pos&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, a_pos: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, b_pos: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a[a_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b[b_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>回文数</title>
      <link>https://just-worker.github.io/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Wed, 07 Jun 2023 22:48:27 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;回文数httpsleetcodecnproblemspalindrome-number&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/palindrome-number/&#34;&gt;回文数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;例如，121 是回文，而 123 不是。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：x = 121&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;首先，从题目上来说，我们有一些简单的过滤条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负数绝对不是回文数&lt;/li&gt;
&lt;li&gt;大于10切以0结尾的绝对不是回文数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩下的当然可以直接反转之后进行值相等判断，但是这样计算太多了点。假设这个回文数位数是偶数，中途计算过程必然存在两个数字相等，奇数的话除去最后一位判断相等即可。这样，我们就把计算的工作量减半了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// tile: O(len)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_palindrome&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; x {
            reverse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; reverse &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; x;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>字符串转换整数</title>
      <link>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</link>
      <pubDate>Tue, 06 Jun 2023 23:59:17 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;字符串转换整数httpsleetcodecnproblemsstring-to-integer-atoi&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/string-to-integer-atoi/&#34;&gt;字符串转换整数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。&lt;/p&gt;
&lt;p&gt;函数 myAtoi(string s) 的算法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入字符串并丢弃无用的前导空格&lt;/li&gt;
&lt;li&gt;检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。&lt;/li&gt;
&lt;li&gt;读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。&lt;/li&gt;
&lt;li&gt;将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。&lt;/li&gt;
&lt;li&gt;如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。&lt;/li&gt;
&lt;li&gt;返回整数作为最终结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;直接解题就好了，注意其中两个个坑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始解析之后，非数字字符都要中断解析，包括符号位和空格。&lt;/li&gt;
&lt;li&gt;解析开始的标记，可以是数字字符，也可以是符号位。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;my_atoi&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch.is_numeric() {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ch.to_digit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).unwrap() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; ;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX;
                    }
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN;
                    }
                }
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; doing {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;+&amp;#39;&lt;/span&gt; {
                doing &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; {
                    sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;边界问题，小心检查。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整数反转</title>
      <link>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 06 Jun 2023 23:50:22 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;h2 id=&#34;整数反转httpsleetcodecnproblemsreverse-integer&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/reverse-integer/&#34;&gt;整数反转&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：x = 123&lt;/li&gt;
&lt;li&gt;输出：321&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(LEN) 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; sign;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; last {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last;
            x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主要在于边界判断&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N字形变换</title>
      <link>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Tue, 06 Jun 2023 22:49:42 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      <description>&lt;h2 id=&#34;n字形变换httpsleetcodecnproblemszigzag-conversion&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/&#34;&gt;N字形变换&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &amp;ldquo;PAYPALISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;直接使用模拟的办法进行解析的话，明显会造成空间的浪费，这里就不说了，详细可以看&lt;a href=&#34;https://leetcode.cn/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/&#34;&gt;官网解答&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;直接计算&#34;&gt;直接计算&lt;/h3&gt;
&lt;p&gt;我们可以思考的是，能够通过数学的规律，直接进行计算。&lt;/p&gt;
&lt;p&gt;分行&lt;code&gt;lines&lt;/code&gt;，明显观察到的规律就是，整个字符周期&lt;code&gt;batch = lines + lines - 2&lt;/code&gt;，其中因为对称的第二列首尾被截取掉了。&lt;/p&gt;
&lt;p&gt;其次，在向上的填充，有对称的部分，很轻易能够计算出，他们的位置其实就是关于&lt;code&gt;lines&lt;/code&gt;的对称。&lt;/p&gt;
&lt;p&gt;现在，分为&lt;code&gt;lines&lt;/code&gt;行，我们直接计算一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![vec![]; lines];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i, ch) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars().enumerate() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; batch;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
                res[idx].push(ch);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                res[batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; idx].push(ch);
            }
        }
        res.concat().iter().collect()
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;直接生成&#34;&gt;直接生成&lt;/h3&gt;
&lt;p&gt;直接计算已经非常不错了，核心关系我们也找到了，能够继续优化呢。&lt;/p&gt;
&lt;p&gt;如果我们直接生成结果，而不用借助多个数组，会怎么样子。可以预见的是，我们将遍历不止一次，重复遍历的次数为&lt;code&gt;lines x N&lt;/code&gt;，时间复杂度并不会涨，但是空间复杂度会降低到&lt;code&gt;O(1)&lt;/code&gt;，因为生成的就是结果本身，不算辅助空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convert&lt;/span&gt;(s: String, rows: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; lines &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; offset &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;lines {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; factor &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; batch;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; chars.len()  {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len() {
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset]);
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; batch &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; offset;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 独行不重复计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; chars.len(){
                    res.push(chars[begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mirror]);
                }
                factor &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里主要的变异点在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要重复遍历&lt;code&gt;lines&lt;/code&gt;遍&lt;/li&gt;
&lt;li&gt;有些行的遍历，一个周期内需要添加两个字符&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串2</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</link>
      <pubDate>Mon, 05 Jun 2023 22:55:57 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B22/</guid>
      <description>&lt;h2 id=&#34;前情回顾&#34;&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/&#34;&gt;最长回文子串&lt;/a&gt;中，我们尝试过两种办法去解答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递推：使用空间记录计算过的结果&lt;/li&gt;
&lt;li&gt;扩展：直接扩展计算匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们尝试去解决这两个方案的缺点。在此之前，因为&lt;code&gt;rust&lt;/code&gt;语法和我不想对&lt;code&gt;i32&lt;/code&gt;妥协的原因，前面的&lt;code&gt;expand&lt;/code&gt;方法实现比较扭曲。
为了这次扩展，重写一下&lt;code&gt;expand&lt;/code&gt;，对&lt;code&gt;i32&lt;/code&gt;进行妥协。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;h3 id=&#34;奇偶串&#34;&gt;奇偶串&lt;/h3&gt;
&lt;p&gt;在使用中心扩展的时候，我们需要扩展两次，因为我们不确定它是奇串还是偶串。这里有一个特殊的特性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于奇数串，它的可插入空位是偶数；对于偶数串，它的可插入空位是奇数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个特性，我们可以对原字符串进行空插，最后得出的一定是奇串；最后去剔除掉插入的字符，这样就能够完美解决奇偶串的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这里的#字符并非一定要是原生字符串之外的字符；因为它自带的对称性并不破坏原有数据的对称性；根据它空插的特性，也可以详细的指定移除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算记忆&#34;&gt;计算记忆&lt;/h3&gt;
&lt;p&gt;之前使用递推，结果不仅时间复杂度没有降低，空间复杂度反而更高，这是为什么呢。主要在于遍历的非线性。我们固然在逻辑上创建了一个具有线性关系的递推式，但是实际遍历过程中，为了维护这种逻辑的线性，我们的遍历方式反而是非线性的，这决定了它的时间复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。其次，我们的存储结构，也要求了空间的复杂度&lt;code&gt;O(N^2)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，核心的关系在于，我们能够找出一种线性的遍历关系，让我们既能线性遍历，又能复用计算结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在强制要求线性遍历的场景下，我们先考察一下是否能够有一种办法去传递我们的计算结果。&lt;/p&gt;
&lt;p&gt;对于未遍历导的场景，遍历是必然的。我们假设在遍历到的一个回文串中，关于中心点对称的两个点的性质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为空插字符，始终是奇串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为两个点都是对称的，因此，他们的回文状态必然也是对称的；这样，的确存在了我们可以复用的传递关系。如果对称点不对称，我们必然要重新进行计算，这里当然选用中心扩展的办法。&lt;/p&gt;
&lt;p&gt;这里引申出两个问题：我们需要如何确定这个对称的中心点，我们需要如何利用这个关系进行传导计算。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了尽可能的复用计算结果，需要尽量将要计算的结果包裹在已经计算的范围内，因此，我们需要最靠近右边的中心对称边界&lt;/li&gt;
&lt;li&gt;如果有对称的结果，我们能够确定最小的对称长度就是：对称点的对称长度和当前点到对称边界的长度&lt;/li&gt;
&lt;li&gt;利用中心扩展，对于已知的对称长度，我们可以直接扩展到指定位置，无需重复计算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这三点，我们已经能够解答提出的疑问。但是还有一个问题，那就是用什么数据结构去描述这个对称结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;臂长&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如无必要，勿增实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据奥卡姆剃刀原则，我们最后的结果实际上只和中心扩展的位置相关，只需要一个数据，无需关心具体的字符。其次，利用空插字符后，始终是进行奇串的中心匹配。&lt;/p&gt;
&lt;p&gt;由此，&lt;code&gt;臂长&lt;/code&gt;这个概念应运而生，关于中心点左右对称，单边长度即为&lt;code&gt;臂长&lt;/code&gt;，回文长度就是两倍的臂长加上作为中心字符的长度。&lt;/p&gt;
&lt;p&gt;至此，我们思考并收集了解题的全部要素。&lt;/p&gt;
&lt;h3 id=&#34;马拉车&#34;&gt;马拉车&lt;/h3&gt;
&lt;p&gt;前面的思路全部聚集，就是大名鼎鼎的&lt;a href=&#34;https://baike.baidu.com/item/Manachar%E7%AE%97%E6%B3%95/20415813?fr=aladdin&#34;&gt;Manachar算法&lt;/a&gt;，小名 &lt;code&gt;马拉车&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要分析一下它的复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为要记住已经计算过的臂长的集合，总的就会有&lt;code&gt;N&lt;/code&gt;个元素，&lt;code&gt;O(N)&lt;/code&gt;空间必不可少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度 : &lt;code&gt;O(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要提前申明的是，中心扩展是同时向两边扩展的，如果单边的长度是&lt;code&gt;N&lt;/code&gt;，总数据长度是&lt;code&gt;2N+1&lt;/code&gt;，但是复杂度依旧是&lt;code&gt;O(N)&lt;/code&gt;。因此这里只讨论单向扩展的问题。对于没有计算过的数据，首次计算他会拓展已经记录的右边界。如果对于已经计算过的对称字符内部，可以复用对称边界内的结果，直接推到边界点开始扩展。&lt;/p&gt;
&lt;p&gt;因此，数据的每次扩展，都只会在边界外进行扩展，也就是说，时间复杂度是&lt;code&gt;O(N)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::fill(s);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; arms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; chars.len()];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;chars.len() {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界内
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; current {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mirror &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; min_arm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::min(arms[mirror], right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; current);
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; min_arm, current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; min_arm);
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Self::arm(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, current, current);
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 马拉车
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; right {
                center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arms[current];
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 题解
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arms[current] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; arms[current];
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界 + 空插字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 空插
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fill&lt;/span&gt;(s: String) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; s.chars() {
            res.push(ch);
            res.push(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 中心扩展
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr[left &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr[right &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] {
            left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// 计算臂长
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arm&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::expand(arr, left, right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
    }
      
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;平心静气&#34;&gt;平心静气&lt;/h2&gt;
&lt;p&gt;仔细研读之后，在细细思索，整理出其中思路不难，整理出自己的思路不难。&lt;/p&gt;
&lt;p&gt;面对问题，主要的是分析，依据自身积累的储备，从各方面和角度进行详细的分析，寻求突破。&lt;/p&gt;
&lt;p&gt;可以不会，但是要学会积累。积累到一定程度，就能够解决一些未知但是可以已知的问题了。要保持思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 04 Jun 2023 22:46:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;最长回文子串httpsleetcodecnproblemslongest-palindromic-substring&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-palindromic-substring/&#34;&gt;最长回文子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：s = &amp;ldquo;babad&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出：&amp;ldquo;bab&amp;rdquo;&lt;/li&gt;
&lt;li&gt;解释：&amp;ldquo;aba&amp;rdquo; 同样是符合题意的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;看到这种类似数组的东西，可能第一想法已经是&lt;code&gt;滑动窗口&lt;/code&gt;一类的了，但是仔细想一下，因为是&lt;code&gt;字符串&lt;/code&gt;，我们可能要重复扫描，滑动窗后就不行了。但是对于复用原来计算结果的&lt;code&gt;关系传递&lt;/code&gt;，我们还是可以利用的，这就诞生了第一种解法。&lt;/p&gt;
&lt;h3 id=&#34;dp&#34;&gt;dp&lt;/h3&gt;
&lt;p&gt;因为不可能一次性扫描，为了复用结果而采用&lt;code&gt;dp&lt;/code&gt;，我们可以轻易的得出如下结论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr[i][i]&lt;/code&gt; 单字符串必然是回文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i] == arr[j]&lt;/code&gt;那么，关键就看&lt;code&gt;arr[i+1]&lt;/code&gt;和&lt;code&gt;arr[j-1]&lt;/code&gt;，如果&lt;code&gt;i + 1 = j&lt;/code&gt;，也是回文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的递推关系出现了，但是问题才刚开始：长字符串始终是依赖短字符串的结果的，那么怎么开始遍历呢。&lt;/p&gt;
&lt;p&gt;我们的递推关系式固然是根据子串的边界，但是需要从小的字符串优先计算，因此，必须使用特殊的遍历技巧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; dp : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length).map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;vec![&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;; string_length]).collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; sub_length &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..=&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; left &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; string_length {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chars[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; chars[right] {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[left&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dp[left][right] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sub_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                    max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sub_length;
                    begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
                }
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(i, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;遍历检测&#34;&gt;遍历检测&lt;/h3&gt;
&lt;p&gt;为什么我们总是去想到一些奇淫技巧呢，可能对于算法题，我们总是感觉有一种&lt;code&gt;技巧性&lt;/code&gt;在里面，否则就无法解题，至少效率不是很高。但是我们在原来的&lt;code&gt;dp&lt;/code&gt;基础上，直接解题会怎么样，我们直接定一个中心，然后向两边进行扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历字符串，定中心&lt;/li&gt;
&lt;li&gt;检测回文，计算结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这似乎更简单，我们尝试一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// spae: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longest_palindrome&lt;/span&gt;(s: String) -&amp;gt; String {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; string_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expand&lt;/span&gt;(arr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, left: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, right: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; arr[left] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; arr[right] {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; arr.len() {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                }
                left &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                right &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars : Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; center &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;string_length {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; odd_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; event_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expand(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;chars, center, center &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::cmp::max(odd_length, event_length);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; center_length &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_length {
                max_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center_length;
                begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; center &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (center_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            }
        }
        chars.iter().enumerate()
        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&amp;amp;&lt;/span&gt;(i, _)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; max_length)
        .map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;(_, v)&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v)
        .collect()

    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然是笨办法，但是在同等时间复杂度下，不需要借助额外的辅助空间也能够达成目的。也就是说，对于递推类问题，维护关系式第一要素，但是无法做到滑动窗口那种对于元素的一次性计算，有可能还会造成空间的浪费。&lt;/p&gt;
&lt;h2 id=&#34;马拉车&#34;&gt;马拉车&lt;/h2&gt;
&lt;p&gt;明天马拉车，代办&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>感情的失真</title>
      <link>https://just-worker.github.io/blog/%E6%84%9F%E6%83%85%E7%9A%84%E5%A4%B1%E7%9C%9F/</link>
      <pubDate>Sat, 03 Jun 2023 21:17:49 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%84%9F%E6%83%85%E7%9A%84%E5%A4%B1%E7%9C%9F/</guid>
      <description>&lt;h2 id=&#34;真切&#34;&gt;真切&lt;/h2&gt;
&lt;p&gt;毋庸怀疑，感情的初心无谓好坏，只是自己内心中真切的抒发。对一个人的爱或憎，无关事理依据，没有深思熟虑，就是心中直接的反应。对于美景的感叹，对于伤痛的怜悯，对于善良回以真心的接纳。初始状态，就连仇恨也显得可爱。&lt;/p&gt;
&lt;p&gt;得到别人的关爱、善意、帮扶，虽然算不得誓死追随，至少心中的那一份尊敬，让人再开口的时候，已经略带些微&lt;code&gt;谦卑&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;可能&lt;code&gt;谦卑&lt;/code&gt;这个词语过分了些，或者说是&lt;code&gt;和气&lt;/code&gt;？只是没有初始的&lt;code&gt;凌人&lt;/code&gt;，怎么会变得和气；而且和气是氛围，绝不是单方面能够造就的。&lt;/p&gt;
&lt;p&gt;唯一能够确定的是，初始的感情，是如此的真切。只是为什么，人逐渐会变得冷漠，才让&lt;code&gt;感动&lt;/code&gt;成为一种能力；因为漠视，还是因为自己心中那一份对&lt;code&gt;认同&lt;/code&gt;的渴望。&lt;/p&gt;
&lt;h2 id=&#34;冲刷&#34;&gt;冲刷&lt;/h2&gt;
&lt;p&gt;当小孩子说出自己心中的想法和情感，得到的回应是可以预料的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关爱：对于童真的回应，对于梦想的扶持&lt;/li&gt;
&lt;li&gt;敷衍：一时的开心的笑容，自己枯燥生活的放纵&lt;/li&gt;
&lt;li&gt;讥笑：深刻的复杂社会认知，对于无知的冷漠&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使是对于&lt;code&gt;关爱&lt;/code&gt;，对于&lt;code&gt;纯真&lt;/code&gt;的呵护也不是持久的，经过社会的渲染，&lt;code&gt;纯真&lt;/code&gt;也只能是以前，很难继续保持了。&lt;/p&gt;
&lt;p&gt;即使是最开始，从小孩子，纯粹的感情也面临时时刻刻的考验，似乎是对于美的迫害；就算拥有护道者的精心呵护，但是免不了更多的风吹雨打。不由想到，在成长的过程中，成年人的考验是什么呢。&lt;/p&gt;
&lt;p&gt;现如今，逐渐丧失尊重的莫过于&lt;code&gt;教师&lt;/code&gt;了。&lt;code&gt;师者，传道受业解惑者也&lt;/code&gt;。不过可惜的是，三大功能，基本上都是自给自足，可以称别人为师，却非&lt;code&gt;教师&lt;/code&gt;；讽刺的是，即使&lt;code&gt;取之于师&lt;/code&gt;，却总是自视&lt;code&gt;自力更生&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这或许是&lt;code&gt;考验&lt;/code&gt;的一种，众口相传的，这似乎是一种&lt;code&gt;自私&lt;/code&gt;。为自己一人之私，享个人之权，弃社会之责。教师只为谋求己身之福，仅凭授课之公，妄代尊父。社会上大多数的情况似乎都是这样，我们总是觉得别人做的不够好，不够多；都是这种心态的话，哪管真实状态是什么，我自一叶障目。&lt;/p&gt;
&lt;p&gt;所谓的&lt;code&gt;考验&lt;/code&gt;，现如今看来，不若一种&lt;code&gt;迫害&lt;/code&gt;的驱使。固然在艰苦环境中保持本心是一种信仰的坚定，是一种&lt;code&gt;考验&lt;/code&gt;；只是，不至于没有环境还要去创建&lt;code&gt;艰苦&lt;/code&gt;。不算&lt;code&gt;背叛&lt;/code&gt;吧，只是首先要生存，&lt;code&gt;坚定&lt;/code&gt;到底是一种自我的良好品质，还是说被人利用。不由让人怀疑&lt;code&gt;环境&lt;/code&gt;的公正性，更多的人，估计光是关心自己的生存，就已经费劲心思了吧；竭力包住这海量的戾气，没有爆发已经足够克制了。&lt;/p&gt;
&lt;p&gt;那从接触之初，克制戾气已经很不容易了。更不用说那些会产生大量负面情绪的行业了，人的神经时刻都被冲刷，时刻面临考研。&lt;/p&gt;
&lt;h2 id=&#34;麻木&#34;&gt;麻木&lt;/h2&gt;
&lt;p&gt;在丧葬场的人的戾气是否已经足够危害他人了呢，似乎并没有，甚至还能听见欢声笑语；听歌打游戏，娱乐也不会禁绝。这么一想，那救死扶伤的医生们，整天散播善意的天使，岂不是将医院都要打造成人间乐土？似乎也并没有，医院内部的&lt;code&gt;商业往来&lt;/code&gt;，也并非太过遥远的夸夸其谈。&lt;/p&gt;
&lt;p&gt;不由得让人侧目：大量的戾气都足够克制了，何以在频繁勾引人极端情绪的地方，却没有引出更多的破坏，或者美好。&lt;/p&gt;
&lt;p&gt;我贫乏的知识，促使我做出的唯一结论，不过是&lt;code&gt;习以为常&lt;/code&gt;罢了。正如千年以来，人并未发现&lt;code&gt;空气&lt;/code&gt;的存在。习以为常，即使是性命攸关的事情，逐渐的也做到了&lt;code&gt;理所当然&lt;/code&gt;。丧葬场中，对于死亡的适应，已经是生活中和柴米油盐一样的理所当然，不用回避，也不用过于惊奇。医院之中，对于善意约莫也是这样的状态，生老病死都已看淡，悲欢离合也是家常便饭，只有自我的生存才是不变的主题。&lt;/p&gt;
&lt;h2 id=&#34;践踏&#34;&gt;践踏&lt;/h2&gt;
&lt;p&gt;物以稀为贵，习以为常的的东西大抵是一文不值的。常常接收到善意的人，对其本人而言，和掏粪工人脚下的大便一样普遍。成年人都是喜欢可爱的小孩子的，可能是因为见过的可爱不多，也可能是小孩子的难能可贵的童真。只是逐渐的发现其无知对于常识的背离，不仅是毫无用处，只是随着时间的流逝，对于这种&lt;code&gt;无知&lt;/code&gt;的习以为常，逐渐的失去耐心，也造就了自身的&lt;code&gt;傲慢&lt;/code&gt;。只有经过长时间的平复，和生活中事实的积累，经历孩子的&lt;code&gt;反叛&lt;/code&gt;，逐步达成&lt;code&gt;和解&lt;/code&gt;，最后发出廉价的老生常谈的父母的&lt;code&gt;欣慰&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有一些偏颇，却不失一丝真实。因为如此，善人大抵是感受不到善的；恶人也没有觉得自己在作恶罢。都是些习以为常的事情。当医生面对家人的感谢地时候，可能只是厌烦，因为他还忙着回家；当恶人面对求饶声的时候，估计也毫无所动，这不过是每个受害者千篇一律的模板行为。三体中的圣母犯下的错误，那就是认为和平理所当然。&lt;/p&gt;
&lt;p&gt;理所当然得事情并不存在，&lt;code&gt;宗教&lt;/code&gt;、&lt;code&gt;战争&lt;/code&gt;、&lt;code&gt;爱情&lt;/code&gt;的存在一再表明，人并不是什么理智的生物。所以理所当然当然是理所当然的。&lt;/p&gt;
&lt;h2 id=&#34;失真&#34;&gt;失真&lt;/h2&gt;
&lt;p&gt;当一个服务员不再去发觉客户的需求的时候，只是机械的执行者作为侍者的引导；甚至丢失侍者的身份，示之以人的是引导者的傲慢；我们需要如何以何种面目，何种感情，何种手段去面对他们。正如前面所说的已经&lt;code&gt;麻木&lt;/code&gt;的人们。&lt;/p&gt;
&lt;p&gt;心里好像有了答案：非真切的感情，不以感情回应。&lt;/p&gt;
&lt;p&gt;理所当然的是，人并非什么理智的生物。对于结论的执行，最终不过也会成为一种形式化的理所当然。对于非真切的教师的漠视，逐渐的变为对于教师的漠视，丢失对于&lt;code&gt;传授&lt;/code&gt;的回应。即使怀着坚定的想法，对一切感情一一回应，理所当然的，最终只会变成千篇一律的形式化。&lt;/p&gt;
&lt;p&gt;感情是不只是发起，它还需要回应；感情是需要传导的。不过现在看来，它失真了；传导过程中，因为成年累月形成的社会规则，一些形态的感情的形式化，使得感情的传导失真了。不管是处于什么样的目的，还是什么样的场景，作为什么样的角色，不可避免的，失真了。&lt;/p&gt;
&lt;h2 id=&#34;规矩&#34;&gt;规矩&lt;/h2&gt;
&lt;p&gt;真切的感情，导致真切的心伤；更多的感情倾注，只会遭遇更多的扭曲。关爱会变成奉承，奉承变成卑微，卑微导致驱使，舔狗最终一无所有？只能说轻易得来的东西，无人感受得到它的分量。无人知晓的感动，无人反抗的暴动，无知导致不合理的东西充斥社会，导致更大的失真。再坚定的人，也会变得麻木。不至于扭曲，但是我们也只能把外壳变得逐渐的坚硬，保留下核心的信仰，不再追求尽善尽美，不再深究细枝末节。&lt;/p&gt;
&lt;p&gt;千万年，千万智者形成的社会，形成了一些无情的规则。我们不至于超越，不过经历初期的怀疑，现在也只能是接受这些规则了。感情这种事情，真的只能放下了；即使是自己情绪，但是也要知道情绪这回事，也是毫无必要的了；一旦发起，只会到达错误的终点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天若有情天亦老，人间正道是沧桑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是时候该沧桑起来了，年轻时候要&lt;code&gt;想&lt;/code&gt;，年轻不再，该&lt;code&gt;做&lt;/code&gt;了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数2</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</link>
      <pubDate>Fri, 02 Jun 2023 20:51:49 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B02/</guid>
      <description>&lt;h2 id=&#34;紧跟上文&#34;&gt;紧跟上文&lt;/h2&gt;
&lt;p&gt;紧跟上文&lt;a href=&#34;https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;，在二分之后，继续深入。&lt;/p&gt;
&lt;h2 id=&#34;原理分析&#34;&gt;原理分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;中位数: 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的分析可以从&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&#34;&gt;官网解析&lt;/a&gt;找到详细的论述，我这里就不多费唇舌。&lt;/p&gt;
&lt;p&gt;结论就是，针对数组&lt;code&gt;a&lt;/code&gt;选取坐标&lt;code&gt;i&lt;/code&gt;，对于数组&lt;code&gt;b&lt;/code&gt;选取坐标&lt;code&gt;j&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;left&lt;/code&gt; : &lt;code&gt;a[0..i] + b[0..j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right&lt;/code&gt; : &lt;code&gt;a[i..] + b[j..]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max(left) &amp;lt;= min(right)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt; a_len, 0 &amp;lt;= j &amp;lt; b_len, i + j = (a_len + b_len + 1) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 i + j 公式来自于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总长偶数: &lt;code&gt;left.len == right.len&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;总长奇数: &lt;code&gt;left.len = right.len + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，换算成等式关系之后，我们只需要检索其中一个数组之后，就可以得出结论了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(min(M, N)))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(a: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#75715e&#34;&gt;// 始终保证 a 长度小于 b
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; b_len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Self::find_median_sorted_arrays(b, a);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, a_len);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_max, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_min) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 检索
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; right {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分检索 i
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 计算对应的 j 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i;
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i-1] 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// a[i]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; a_i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                a[i]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j-1]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j_prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MIN
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// b[j]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 边界最大
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;::MAX
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                b[j]
            };
            &lt;span style=&#34;color:#75715e&#34;&gt;// 满足条件，非最大 i ,向右查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_i_prev &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; b_j {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 左侧数组的最大值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                a_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::max(a_i_prev, b_j_prev);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 右侧数组的最小值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                b_min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_i, b_j);
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向右推进
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { 
                &lt;span style=&#34;color:#75715e&#34;&gt;// 向左查找
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 左侧 多收容，中位数就是左侧最大数字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            a_max &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 双边界平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            (a_max &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_min) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;降维打击&#34;&gt;降维打击&lt;/h2&gt;
&lt;p&gt;看完之后，只能说要常复习，常练习，只能看懂却不能掌握，实在太遗憾。&lt;/p&gt;
&lt;p&gt;同时，有两个启发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另辟蹊径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题中，从另一个角度去分析题目，把一道&lt;code&gt;搜索题&lt;/code&gt;变成了一道&lt;code&gt;计算题&lt;/code&gt;。虽然还是有搜索的部分，但是更偏向于&lt;code&gt;计算+匹配&lt;/code&gt;了，比起之前的简单计算+复杂搜索，把搜索的复杂度，向计算过度，从而达到足够优化的算法复杂度；进一步对原有的实现方法形成降维打击。&lt;/p&gt;
&lt;p&gt;一方面，可以说是思维的精妙。一般时间复杂度的降低，除了大量空间的牺牲可以提高，剩下的只能够凭借精妙的算法得以达成。&lt;/p&gt;
&lt;p&gt;另一方面，则是思维上的开拓。不仅仅是对于思维的跳脱，还需要有开阔的眼界，否则，何来的素材；多积累才有的多选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系传导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多事情，哪怕算法，只有抓到核心关键，才能够事半功倍。正如斐波那契，正如汉诺塔。如果只是一昧的暴力，总有碰壁的时候。同样是规律，越是接近事物的本质，效率也来的更加的快速；刨除了无用的损耗，效率自然成倍的提高。&lt;/p&gt;
&lt;p&gt;越来越相信大道至简，因为越是了解越多，越是接近本质，如此的简单，威力却如此的巨大。降维打击，莫过如此。&lt;/p&gt;
&lt;p&gt;的确，如果真的想要时时顺心，事事如意，我们必须要提高我们的效率，去达成面临的事情；但是面临的事情逐渐的庞大，我们的效率不能只是&lt;code&gt;速度&lt;/code&gt;，还要有&lt;code&gt;质量&lt;/code&gt;，快速的，摧枯拉朽的去解决掉阻碍的事情，这才是我们需要积累的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>寻找两个正序数组的中位数</title>
      <link>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Thu, 01 Jun 2023 22:51:53 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>&lt;h2 id=&#34;寻找两个正序数组的中位数httpsleetcodecnproblemsmedian-of-two-sorted-arrays&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/median-of-two-sorted-arrays/&#34;&gt;寻找两个正序数组的中位数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度应该为 O(log (m+n)) 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums1 = [1,3], nums2 = [2]&lt;/li&gt;
&lt;li&gt;输出：2.00000&lt;/li&gt;
&lt;li&gt;解释：合并数组 = [1,2,3] ，中位数 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;数组的中位数，值的一提的就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组长度是奇数，中位数就是有序数组的最中间的值&lt;/li&gt;
&lt;li&gt;如果数组长度是偶数，中位数就是有序数组中间两个值的平均&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算过程中，假设排序数组为&lt;code&gt;arr&lt;/code&gt;，数据长度为&lt;code&gt;len&lt;/code&gt;，中位数表示如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组长度为奇数: &lt;code&gt;arr[len / 2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组长度为偶数: &lt;code&gt;(arr[len / 2] + arr[len / 2 + 1]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然是分支逻辑，但是通过特殊的计算，我们可以合并为相同的逻辑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(arr[(len + 1) / 2] + arr[(len + 2) / 2]) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就能够更简单的进行问题的求解。&lt;/p&gt;
&lt;p&gt;本题目求解不难，难点在于&lt;code&gt;O(log(m + n))&lt;/code&gt;的时间复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于合并之后直接求解的办法已经说明，这里专注其他技巧求解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h3&gt;
&lt;p&gt;目前滑动窗口的出镜率极高，这道题也可用滑动窗口进行求解。并且和之前的&lt;code&gt;缓存&lt;/code&gt;有很大的区别，&lt;code&gt;窗口&lt;/code&gt;本身的概念也于抽象。&lt;/p&gt;
&lt;p&gt;其实找到中位数，并不一定需要合并到同一个数组，使用两个指针维护查找的队列，其实就可以达到同样的目的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M + N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nums1.len(), nums2.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a_len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b_len;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_idx, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_idx) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; current, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; current;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b_len {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums1[a_idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums2[b_idx] {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1[a_idx];
                a_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums2[b_idx];
                b_idx &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (current &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; last &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; ) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;二分法&#34;&gt;二分法&lt;/h3&gt;
&lt;p&gt;其实对于&lt;code&gt;O(log(m + n))&lt;/code&gt;的第一反应，必定就是二分法，关键在于如何构造二分。&lt;/p&gt;
&lt;p&gt;这里其实有一个很细微的理解问题，正如&lt;code&gt;三&lt;/code&gt;在古文中表示的意思是&lt;code&gt;多&lt;/code&gt;，而非真的是&lt;code&gt;3&lt;/code&gt;。所谓的二分法，并非严格意义上的丛中分断，它不仅可以是&lt;code&gt;1/n&lt;/code&gt;，甚至在一些边界条件中，也是允许不严格的划分的。尤其是其中的&lt;code&gt;O(log(m + n))&lt;/code&gt;，底数并没有固定展示，这只是一种表示方法，一种趋势，如果是&lt;code&gt;1/n&lt;/code&gt;分，底数不过就变成了&lt;code&gt;n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;说到这里，结合前面的方法，其实我们已经掌握了核心的办法，这要从两个问题进行引申&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是单个数组的话，直接通过计算就可以得出结果，但是我们为什么需要进行查找。查找其实只是为了区分两个数组之间的关系，而对于一个数组中的中位数，我们可以直接计算出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于滑动窗口的优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，边界情况下，只剩下了一个数组，我们可以直接进行计算，而非继续傻傻的一个个查找。但是为什么会到这一步呢，因为我们&lt;code&gt;排除&lt;/code&gt;了其中一些非法的答案。查找类的问题经常有两种办法进行求解，正向的匹配检查，和反向的非法排除。常用的二分法，其实就是在规则匹配的条件下对空间进行排除，并且排除优先于匹配。可能对于经典的二分法而言，每一步空间的缩小似乎都是正向的匹配，但其实排除大量的干扰，才是二分的要义。&lt;/p&gt;
&lt;p&gt;可能相较于单个数组的精准匹配，排除似乎更废时间；但是对于本题中类似的模糊区间查找，排除才是王道。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(log(m+n))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::cmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_median_sorted_arrays&lt;/span&gt;(nums1: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, nums2: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums1.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums2.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 两数平均
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, left) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Self::find_nth(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums1, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nums2, right)) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_nth&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, k: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (a_len, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a.len(), b.len());
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a_begin, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b_begin) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 单边直接计算
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; b[b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;b_len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a[a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cmp::min(a[a_begin], b[b_begin]) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 二分移除： 因为对于half而言是可以稳定移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; half &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 边界条件下非二分移除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, a_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cmp::min(b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; half, b_len) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 降低 k 缩小边界
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a[next_a_begin] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; b[next_b_begin] {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                a_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_a_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                k &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                b_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_b_begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二分之所以威力巨大，其实是因为它只用判断一半的元素，正如我们查找中位数，正向查找完全不好关心后半截的数据一样。&lt;/p&gt;
&lt;h3 id=&#34;反向排除&#34;&gt;反向排除&lt;/h3&gt;
&lt;p&gt;在迷茫的时候，缺乏正确的指引，盲目的追求正确，试错成本很高，而且可能要经受多次的失败。但如果是深思熟虑，通过少数的关键特征，些许的试错然后去排除错误的选项，这就能让我们更快，更有效的找到正确的选项。&lt;/p&gt;
&lt;p&gt;学习算法，学会高效的处理的方式，同样可以使用于人生。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串</title>
      <link>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 31 May 2023 23:04:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;h2 id=&#34;无重复字符的最长子串httpsleetcodecnproblemslongest-substring-without-repeating-characters&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&#34;&gt;无重复字符的最长子串&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入: s = &amp;ldquo;abcabcbb&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输出: 3&lt;/li&gt;
&lt;li&gt;解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;对于这种基础的题目，爆破始终是第一选项。如果有过更近一步的经验，感觉也能和递推产生一些关系。但是首选项必然是&lt;code&gt;滑动窗口&lt;/code&gt;。
&lt;code&gt;滑动窗口&lt;/code&gt;其实没有什么高深的原理，只是维护一个动态的窗口条件，通过边界的缩放，判断、修改窗口内的数据关系。不过是看起来像窗口而已，我更宁愿把它归纳为之前提炼出来的&lt;code&gt;关系传导&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然是使用&lt;code&gt;缓存&lt;/code&gt;的，但是这所谓缓存的结果，隐含了之前计算的元素之间的微妙联系。滑动窗口也是如此，它通过窗口边界的收缩，把某种关系限定在窗口数据内，当我们进行新一轮的判断的时候，&lt;code&gt;关系&lt;/code&gt;的传导让我们不必关心更多的干扰，从而去针对的制定逻辑。把纷繁的问题逐步拆分，这样就使得求解变得简单、清晰。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) 需要遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(X) 字符集长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashSet;
&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;length_of_longest_substring&lt;/span&gt;(s: String) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.chars().collect::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; container &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashSet::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; right &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[right];
            &lt;span style=&#34;color:#75715e&#34;&gt;// 剔除重复字符串
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; container.contains(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ch) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; left_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; chars[left];
                container.remove(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;left_char);
                left &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 窗口内有效字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            container.insert(ch);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; container.len() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res {
                res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; container.len();
            }
        }
        res &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基础维护&#34;&gt;基础维护&lt;/h2&gt;
&lt;p&gt;我们为什么需要学习，因为我们想具备某种能力，从而让自己变得更加的自由。&lt;/p&gt;
&lt;p&gt;这里隐含了一种关系，&lt;code&gt;维护&lt;/code&gt;和&lt;code&gt;使用&lt;/code&gt;。学习红黑树的时候，让我十分厌倦；不论是各种旋转还是条件、染色，只是让我觉得啰嗦。我觉得学习这种东西，除了应付差事，我大概永远和它无缘。后面知晓数据库使用了树结构，其实我也有一种想法，觉得数据库简直多余。的确，&lt;code&gt;维护&lt;/code&gt;是无用的，耗时且费力的，默默无闻一辈子，可能光辉的一瞬都不一定能换回来。&lt;/p&gt;
&lt;p&gt;但是，俗话说得好，&lt;code&gt;一口吃不成&lt;/code&gt;胖子。想要成为胖子，那是需要&lt;code&gt;日积月累&lt;/code&gt;的，&lt;code&gt;水滴石穿，非一日之功&lt;/code&gt;。面对一些事情，我们的能力，我们的选择，并不能&lt;code&gt;一蹴而就&lt;/code&gt;。正如使用数据库，尽管实现很麻烦，使用&lt;code&gt;SQL&lt;/code&gt;也不简单，但是面对海量的数据的时候，我们能够轻易的完成查找、聚合、排序等操作。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。显而易见的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比起瞬间聚集的能力，维护是小步的、简单的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;我这一拳二十年的功力，你挡得住么&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;正如扭螺丝的奇葩账单，有些简单的事情背后真的很不简单。为什么不同岗位的工资差别如此的巨大，仅仅是因为工作内容的不一致么。并不是，而是来源于工作能力的培养难度。学了二十年才能出师的岗位，显然比学习一周上岗的岗位薪酬高的多。这全部是&lt;code&gt;维护&lt;/code&gt;的功劳。短小的时日并不能集聚太多的知识。&lt;/p&gt;
&lt;p&gt;这也正是要专心写博客的原因，没有之一。你想有的能力，需要维护。维护的多好，当你使用的时候就能发挥多大的效果。比起完成瞬间积聚巨大能量的不可能，水滴石穿、细水长流的积累，显得如此的轻松。请放心，付出终究会有收获，如果每一份耕耘都太过艰难，那只是预示你将会有巨大的丰收。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数相加</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Tue, 30 May 2023 22:55:18 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>&lt;h2 id=&#34;两数相加httpsleetcodecnproblemsadd-two-numbers&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/add-two-numbers/&#34;&gt;两数相加&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：l1 = [2,4,3], l2 = [5,6,4]&lt;/li&gt;
&lt;li&gt;输出：[7,0,8]&lt;/li&gt;
&lt;li&gt;解释：342 + 465 = 807.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;逐位相加，算是最简单的办法了；当然，也可以转换成数字后相加，但是如果数据溢出，也会有问题。&lt;/p&gt;
&lt;p&gt;本题最关键的，就是如何计算&lt;code&gt;进位&lt;/code&gt;。当然，谁都能看出来，但是最关键有如下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位数补齐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果其中一个链表用完了该怎么办呢，可能大多数人直接反应就是将后续的列表进行拼接，容易忽略进位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算出的结果也不一定就是和最大输入同长度的，额外的进位需要再后面进行补足。&lt;/p&gt;
&lt;p&gt;和上一篇&lt;a href=&#34;https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/&#34;&gt;两数之和&lt;/a&gt;一样，所谓进位，也可以算得上一种关系的固化和传递，虽然很浅显，但是需要继续保有这种意识，才能逐步加深认知，才能敏锐的发现一些相似的东西。&lt;/p&gt;
&lt;h3 id=&#34;原始解题&#34;&gt;原始解题&lt;/h3&gt;
&lt;p&gt;先用最简单的办法实现一遍。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; l1.is_some() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; l2.is_some() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l1.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.unwrap();
                a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l2.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2.unwrap();
                b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val;
                l2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.next;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)));
        }
        res
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (l1, l2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// (list1, list2, sum, carry)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
            data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; data {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 无数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;,
                &lt;span style=&#34;color:#75715e&#34;&gt;// 直接进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (None, None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; (None, None, carry, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;),
                &lt;span style=&#34;color:#75715e&#34;&gt;// 其中一个有数据，且能进位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(list), None, _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(list), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (list.next, None, sum, c)
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 两个数进位加法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                (Some(l1), Some(l2), _, carry) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; l2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                        sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    }
                    (l1.next, l2.next, sum, c)
                }
            };

            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(data.&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)));
            last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next;
        }
        res
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;递归处理&#34;&gt;递归处理&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(M+N)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers&lt;/span&gt;(l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; res;
        Self::add_two_numbers_recursive(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, last, l1, l2);
        res
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_two_numbers_recursive&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; carry: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, last: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l1: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, l2: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; (l1, l2, carry) {
            (None, None, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))),
            (Some(node), None, _) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (None, Some(node), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node.next, None);
            },
            (Some(node1), Some(node2), _) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node1.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; node2.val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; carry;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
                    sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                    carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
                &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(Box::new(ListNode::new(sum)));
                Self::add_two_numbers_recursive(carry, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; last.as_mut().unwrap().next, node1.next, node2.next);
            },
            _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {}
            
        }  
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;优化处理&#34;&gt;优化处理&lt;/h2&gt;
&lt;p&gt;关于这个问题的主体，还是在&lt;code&gt;进位&lt;/code&gt;的计算，不论是只剩下单边数据了还能继续进位，还是说溢出产生的额外进位。&lt;/p&gt;
&lt;p&gt;虽然问题的核心得到了解决，不过还有几个方面让我们的方案变得更好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进位终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面虽然说了即使单边数据也能连续进位，但是对于不可进位的单边数据，可以采取直接嫁接的方法，提前结束判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原地相加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以不利用额外的数据结构，直接以单边数据为容器进行相加。不过这种方式还是避免不了进位溢出和选取了数据较短的一方，空间复杂度还是一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两数之和</title>
      <link>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 29 May 2023 23:31:46 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>&lt;h2 id=&#34;两数之和httpsleetcodecnproblemstwo-sum&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/two-sum/&#34;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标值 &lt;code&gt;target&lt;/code&gt;  的那两个整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入：nums = [2,7,11,15], target = 9&lt;/li&gt;
&lt;li&gt;输出：[0,1]&lt;/li&gt;
&lt;li&gt;解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;题目分析&#34;&gt;题目分析&lt;/h2&gt;
&lt;h3 id=&#34;爆破&#34;&gt;爆破&lt;/h3&gt;
&lt;p&gt;对于这道题，粗暴的求解方式就是对于数组中的的两两组合求值，从而判断结果是否符合答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(n^2) : 最坏情况需要遍历全部可能配对
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(1)  : 无额外空间消耗
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.len();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;(len &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[j] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; , j &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;];
                }
            }
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;按图索骥&#34;&gt;按图索骥&lt;/h3&gt;
&lt;p&gt;这里有两个特殊的视角&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于确定等式的三个数值，我们只要确定了其中两个，就能够唯一确定第三个&lt;/li&gt;
&lt;li&gt;可以列一个清单去进行匹配，而不是每次都需要重新计算(缓存)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质的核心，其实就是等式关系的延续，把一个&lt;code&gt;满足等式的数&lt;/code&gt;的判断，转化为&lt;code&gt;某个确定的数&lt;/code&gt;的限定条件。&lt;!-- raw HTML omitted --&gt;
更关键的是，对于&lt;code&gt;target&lt;/code&gt;和&lt;code&gt;nums[?]&lt;/code&gt;的依赖，做了一个特殊的持久化，不用每次计算都携带，降低了信息传递的消耗。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;span style=&#34;color:#75715e&#34;&gt;// time: O(N) : 只用遍历一遍
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space: O(N) : 最坏情况首尾相加
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Solution {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, target: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HashMap::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;::new();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;nums.len() {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.get(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; last.is_some() {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec![last.unwrap().to_owned(), index];
            }
            map.insert(target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; value, index);
        }
        unreachable!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;illegal status&amp;#34;&lt;/span&gt;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关键技巧&#34;&gt;关键技巧&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;缓存&lt;/code&gt;固然是一个关键的技巧，但是我更宁愿把&lt;code&gt;固化&lt;/code&gt;称为其中核心秘籍。&lt;/p&gt;
&lt;p&gt;正是因为&lt;code&gt;固化&lt;/code&gt;了其中的计算关系，&lt;code&gt;缓存&lt;/code&gt;才能发挥更大的能力。
所谓&lt;code&gt;缓存&lt;/code&gt;，其实就是耗费资源去得到的一个结果，当我们重复的去获取这个结果的时候，使用已经计算好的副本，能够极大的避免计算的开销。
因此，在涉及重复计算的场景下，缓存有很大的作用空间；但是，&lt;code&gt;固化&lt;/code&gt;作为其核心要义，并非只是简单的存储结果。
一个计算结果本身就有来由的原因。&lt;/p&gt;
&lt;p&gt;本题中，正式因为把算式的因果关系转换，并且利用缓存进行&lt;code&gt;固化&lt;/code&gt;，把查找转换为匹配，才根源上完成解题的突破。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记录的必要</title>
      <link>https://just-worker.github.io/blog/%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BF%85%E8%A6%81/</link>
      <pubDate>Sun, 28 May 2023 23:41:19 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BF%85%E8%A6%81/</guid>
      <description>&lt;h2 id=&#34;为什么记录&#34;&gt;为什么记录&lt;/h2&gt;
&lt;p&gt;今天突然有一个感悟：先有的目的，然后有的方法。或者说，因为想，所以成。虽然有点心想事成的玄学，但事实的确如此。&lt;/p&gt;
&lt;p&gt;生活之中，别人向你求解某些东西的时候，别人弄不明白，反而说你讲不清楚；这让人十分的气愤。不过，有些人，的确也会，却热衷于让人弄明白，也让我感叹：这真是十足的叛徒。
不论他背叛的了什么，但是后续一种称为&lt;code&gt;沟通技巧&lt;/code&gt;的东西的确的会流传开，正如开发背叛了技术，去舔了产品，从而出现了&lt;code&gt;DDD&lt;/code&gt;。开个玩笑，不过事实的确如此。抛开主观的臆想和情绪，真正的投入到关注的东西上面去，才会真的衍生出某种超脱的东西，而非局限于现状。终究，研究的东西终会明了，阻碍的问题也会得以解决。&lt;/p&gt;
&lt;p&gt;这对于我而言，真的十分重要，至少，我发现很多时候我都在原地踏步。谈不上刻苦，算不上勤勉，也不是懒惰，我还是有一点点的努力的。只是偶尔回顾的时候，我发现我始终在重复。之前我的观点是，&amp;ldquo;脚踏实地，一步一步&amp;rdquo;，但是一直没能前进。后来，我想的是先探路，再夯实，结果是脚步虚浮。现在，我不知道我经历过什么，也说不清我将要遭遇什么，对于过去和现在以及将来，似乎有所感，却朦朦胧胧。&lt;/p&gt;
&lt;p&gt;这就是我现在面临的最大的问题：不清晰。&lt;/p&gt;
&lt;p&gt;必定是有什么办法去解决的，只要我真的关注这件事情，不分心，也不推辞的话。过去的学习，思考和经验，由于没有进一步的归纳和总结，它们就消逝得无影无踪，但的确的曾经出现过。
这是必然是让人恍惚的，当再次回忆的时候，那种朦胧和迷离，给不了当下的我一种明晰的回馈。由此，它给我带来了一些盲目的自信，因为一个圆满的成功，一个失误都消逝了的单纯的结果；它也给我带来更多惶恐的自卑，因为一个虚浮的结果，一个没用具体支撑的空中楼阁。这种糟糕的心灵折磨，每天都轮番上阵。尤其是当我正投入的学习的时候，总是会回想起我上一次的学习，明白的告诉我，这的确是我对于同样的东西的不只一次的学习，明确的表明，我仍然没有学会，以及领悟更多的东西。&lt;/p&gt;
&lt;p&gt;势必要让它变得更明白一些了。让一些念头，真切的坦露；让一些学习，镌刻心头；让一些妄念，剥离开来。我想当我谈及某种东西的时候，我能够清晰的回忆起细节；记忆固然是不可靠的，那我也能找到我当时的领悟。简而言之，我想让将来的我，能够稳定且准确的回到我当前的状态；只有这样，我才能够为自己的努力自豪；也才能够依循上次的脚步，继续加深，而非从头来过。&lt;/p&gt;
&lt;p&gt;那就详细的记录下来，关于自己的学习，自己的思想。把真实留住，把妄想驱逐。&lt;/p&gt;
&lt;h2 id=&#34;记录些什么&#34;&gt;记录些什么&lt;/h2&gt;
&lt;p&gt;从我现在的需求，应该能够确定我将来需要回溯的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我想发挥的时候，我能分辨我是否有(过)这种能力&lt;/li&gt;
&lt;li&gt;当我想学习的时候，我能知晓我的学习程度&lt;/li&gt;
&lt;li&gt;当我想规划的时候，我能权衡我的知识储备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，我应该详尽的去记录自己想要回溯的状态，尽量的表明我所掌握的知识，体现我掌握的程度。不要夸大，也不要遗漏，即使是错误的也不要紧，后续我也能够发现自己的更正(进步)。&lt;/p&gt;
&lt;p&gt;回到之前所说的感悟，套用到我当前的状态。正式因为要解决我当前的迷茫状态，我才需要去分析和关注我当前的行为。可能不能够马上达到正确的结果，但是我需要继续专注。&lt;/p&gt;
&lt;h2 id=&#34;记录的规则&#34;&gt;记录的规则&lt;/h2&gt;
&lt;p&gt;即使当前只有一个模糊的想法，但是把它逐渐清晰的雕刻出来，才是最终的目的。因此，需要一些限制，防止懒散入侵，让此刻的想法得以坚持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每天都要记录
这是最基础的点了，我觉得要必要保持每天的思考。顶层设计，自上而下的倒逼的话，就是每天都需要记录，以此来强迫自己每日对于思考的追逐。&lt;/li&gt;
&lt;li&gt;非发泄的记录
记录的东西可以是学习，可以是回忆，可以是感想，唯独不能是单纯的情绪发泄。记录将是一种旅行，每一步都将是脚印，让脚印清晰，让脚印整齐，让脚印前进这才有记录的意义。纯粹的情绪发泄，正如原地踏步，它无法深刻任何东西，感受不到任何具体，不能让人前进。&lt;/li&gt;
&lt;li&gt;清晰的分类
记录的范围的确过于宽泛了，但是目前也不能够约定的足够详细，那样就抹灭了灵性。因此，对于宽泛的记录，有必要分门别类的进行整理，需要慎重、清晰的对文章进行标记整理。&lt;/li&gt;
&lt;li&gt;准确且详细的表达
记录不仅仅是给自己带来自信，不可否认的一点，将来某一时刻，它必将被查看，或者说，我们都将回到现在。因此，关于现在的记录，势必要有一定的详尽且真实的记载。在将来的某一刻，我们才能够准确无误的抵达现在，没有虚假，也没有确实，完整的回来。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>再一次开始</title>
      <link>https://just-worker.github.io/blog/%E5%86%8D%E4%B8%80%E6%AC%A1%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sat, 27 May 2023 21:17:35 +0800</pubDate>
      
      <guid>https://just-worker.github.io/blog/%E5%86%8D%E4%B8%80%E6%AC%A1%E5%BC%80%E5%A7%8B/</guid>
      <description>&lt;h2 id=&#34;赏心悦目的博客&#34;&gt;赏心悦目的博客&lt;/h2&gt;
&lt;p&gt;从最开始的 &lt;code&gt;csdn&lt;/code&gt;，后面的 &lt;code&gt;gitPages&lt;/code&gt; ，后续自建的 &lt;code&gt;hexo&lt;/code&gt;。不断来回反复，却始终原地踏步。
我不太确信博客的定义，我只是希望它&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无广告&lt;/li&gt;
&lt;li&gt;简洁轻便明了&lt;/li&gt;
&lt;li&gt;公网访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以此去规范自己逐步的学习、记录进步。&lt;/p&gt;
&lt;p&gt;现在，我大概找到了最中意的样式和方式了。剩下的，只能是向内求取了，也杜绝了分神的接口。&lt;/p&gt;
&lt;h2 id=&#34;迟迟未到的觉悟&#34;&gt;迟迟未到的觉悟&lt;/h2&gt;
&lt;p&gt;一直都是觉得，&lt;code&gt;只有...我才能...&lt;/code&gt;。这么一个欺骗自己的句式，因为之前的太多铺垫造就的顺风，让我沉迷太久。
现在也算是划一个句号吧。年龄比觉悟早早的就到了，我也不确定这个觉悟能够持续多久。可能过不了多久就会消散，也没有确切的方法一直维持；唯一能做的，就是应该把当前想做的做到，让后续的努力不再重复，得以到达更远的地方。&lt;/p&gt;
&lt;h2 id=&#34;稳稳当当的以后&#34;&gt;稳稳当当的以后&lt;/h2&gt;
&lt;p&gt;不一定是稳定的，可能也会继续波折。
只是对个人而言，我希望今后能够稳定一点。学习和积累方面吧，其他方面个人说了也不算。
今后博客这条路也就不再重复了，也不找借口挥霍时间和精力了。&lt;/p&gt;
&lt;p&gt;记录生活，记录学习，记录人生；从现在开始。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>